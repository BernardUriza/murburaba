{"version":3,"file":"index.umd.min.js","sources":["../src/core/EventEmitter.ts","../src/core/StateManager.ts","../src/core/Logger.ts","../src/types/audio-types.ts","../src/managers/WorkerManager.ts","../src/managers/MetricsManager.ts","../src/managers/ChunkProcessor.ts","../src/core/MurmubaraEngine.ts","../src/api.ts","../src/hooks/useMurmubaraEngine.ts","../src/engines/RNNoiseEngine.ts","../src/hooks/useAudioEngine.ts","../src/engines/index.ts","../src/index.ts"],"sourcesContent":["export type EventHandler = (...args: any[]) => void;\n\nexport class EventEmitter<T extends Record<string, EventHandler>> {\n  private events: Map<keyof T, Set<EventHandler>> = new Map();\n  \n  on<K extends keyof T>(event: K, handler: T[K]): void {\n    if (!this.events.has(event)) {\n      this.events.set(event, new Set());\n    }\n    this.events.get(event)!.add(handler);\n  }\n  \n  off<K extends keyof T>(event: K, handler: T[K]): void {\n    const handlers = this.events.get(event);\n    if (handlers) {\n      handlers.delete(handler);\n      if (handlers.size === 0) {\n        this.events.delete(event);\n      }\n    }\n  }\n  \n  emit<K extends keyof T>(event: K, ...args: Parameters<T[K]>): void {\n    const handlers = this.events.get(event);\n    if (handlers) {\n      handlers.forEach(handler => {\n        try {\n          handler(...args);\n        } catch (error) {\n          console.error(`Error in event handler for ${String(event)}:`, error);\n        }\n      });\n    }\n  }\n  \n  once<K extends keyof T>(event: K, handler: T[K]): void {\n    const wrappedHandler = ((...args: any[]) => {\n      this.off(event, wrappedHandler as T[K]);\n      handler(...args);\n    }) as T[K];\n    this.on(event, wrappedHandler);\n  }\n  \n  removeAllListeners(event?: keyof T): void {\n    if (event) {\n      this.events.delete(event);\n    } else {\n      this.events.clear();\n    }\n  }\n  \n  listenerCount(event: keyof T): number {\n    const handlers = this.events.get(event);\n    return handlers ? handlers.size : 0;\n  }\n}","import { EngineState } from '../types';\nimport { EventEmitter } from './EventEmitter';\n\ninterface StateEvents {\n  'state-change': (oldState: EngineState, newState: EngineState) => void;\n  [key: string]: (...args: any[]) => void;\n}\n\nexport class StateManager extends EventEmitter<StateEvents> {\n  private currentState: EngineState = 'uninitialized';\n  private allowedTransitions: Map<EngineState, EngineState[]> = new Map([\n    ['uninitialized', ['initializing', 'error']],\n    ['initializing', ['ready', 'error']],\n    ['ready', ['processing', 'destroying', 'error']],\n    ['processing', ['ready', 'paused', 'destroying', 'error']],\n    ['paused', ['processing', 'ready', 'destroying', 'error']],\n    ['destroying', ['destroyed', 'error']],\n    ['destroyed', []],\n    ['error', ['initializing', 'destroying']],\n  ]);\n  \n  getState(): EngineState {\n    return this.currentState;\n  }\n  \n  canTransitionTo(newState: EngineState): boolean {\n    const allowed = this.allowedTransitions.get(this.currentState) || [];\n    return allowed.includes(newState);\n  }\n  \n  transitionTo(newState: EngineState): boolean {\n    if (!this.canTransitionTo(newState)) {\n      console.warn(\n        `Invalid state transition: ${this.currentState} -> ${newState}`\n      );\n      return false;\n    }\n    \n    const oldState = this.currentState;\n    this.currentState = newState;\n    this.emit('state-change', oldState, newState);\n    return true;\n  }\n  \n  isInState(...states: EngineState[]): boolean {\n    return states.includes(this.currentState);\n  }\n  \n  requireState(...states: EngineState[]): void {\n    if (!this.isInState(...states)) {\n      throw new Error(\n        `Operation requires state to be one of: ${states.join(', ')}, ` +\n        `but current state is: ${this.currentState}`\n      );\n    }\n  }\n  \n  reset(): void {\n    const oldState = this.currentState;\n    this.currentState = 'uninitialized';\n    if (oldState !== 'uninitialized') {\n      this.emit('state-change', oldState, 'uninitialized');\n    }\n  }\n}","import { LogLevel } from '../types';\n\nexport class Logger {\n  private level: LogLevel = 'info';\n  private onLog?: (level: LogLevel, message: string, data?: any) => void;\n  private prefix: string;\n  \n  constructor(prefix: string = '[Murmuraba]') {\n    this.prefix = prefix;\n  }\n  \n  setLevel(level: LogLevel): void {\n    this.level = level;\n  }\n  \n  setLogHandler(handler: (level: LogLevel, message: string, data?: any) => void): void {\n    this.onLog = handler;\n  }\n  \n  private shouldLog(level: LogLevel): boolean {\n    const levels: LogLevel[] = ['none', 'error', 'warn', 'info', 'debug'];\n    const currentIndex = levels.indexOf(this.level);\n    const messageIndex = levels.indexOf(level);\n    return currentIndex > 0 && messageIndex <= currentIndex;\n  }\n  \n  private log(level: LogLevel, message: string, data?: any): void {\n    if (!this.shouldLog(level)) return;\n    \n    const timestamp = new Date().toISOString();\n    const formattedMessage = `${this.prefix} [${timestamp}] [${level.toUpperCase()}] ${message}`;\n    \n    if (this.onLog) {\n      this.onLog(level, formattedMessage, data);\n    } else {\n      const logMethod = level === 'error' ? console.error : \n                       level === 'warn' ? console.warn : \n                       console.log;\n      \n      if (data !== undefined) {\n        logMethod(formattedMessage, data);\n      } else {\n        logMethod(formattedMessage);\n      }\n    }\n  }\n  \n  error(message: string, data?: any): void {\n    this.log('error', message, data);\n  }\n  \n  warn(message: string, data?: any): void {\n    this.log('warn', message, data);\n  }\n  \n  info(message: string, data?: any): void {\n    this.log('info', message, data);\n  }\n  \n  debug(message: string, data?: any): void {\n    this.log('debug', message, data);\n  }\n}","export type EngineState = \n  | 'uninitialized'\n  | 'initializing'\n  | 'loading-wasm'\n  | 'creating-context' \n  | 'ready'\n  | 'processing'\n  | 'paused'\n  | 'destroying'\n  | 'destroyed'\n  | 'error'\n  | 'degraded';\n\nexport type LogLevel = 'none' | 'error' | 'warn' | 'info' | 'debug';\nexport type NoiseReductionLevel = 'low' | 'medium' | 'high' | 'auto';\nexport type Algorithm = 'rnnoise' | 'spectral' | 'adaptive';\nexport type BufferSize = 256 | 512 | 1024 | 2048 | 4096;\n\nexport interface MurmubaraConfig {\n  logLevel?: LogLevel;\n  onLog?: (level: LogLevel, message: string, data?: any) => void;\n  noiseReductionLevel?: NoiseReductionLevel;\n  bufferSize?: BufferSize;\n  algorithm?: Algorithm;\n  autoCleanup?: boolean;\n  cleanupDelay?: number;\n  useWorker?: boolean;\n  workerPath?: string;\n  allowDegraded?: boolean;\n}\n\nexport interface StreamController {\n  stream: MediaStream;\n  processor: AudioProcessor;\n  stop: () => void;\n  pause: () => void;\n  resume: () => void;\n  getState: () => EngineState;\n}\n\nexport interface AudioProcessor {\n  id: string;\n  state: EngineState;\n  inputNode?: AudioNode;\n  outputNode?: AudioNode;\n}\n\nexport interface ProcessingMetrics {\n  noiseReductionLevel: number;\n  processingLatency: number;\n  inputLevel: number;\n  outputLevel: number;\n  timestamp: number;\n  frameCount: number;\n  droppedFrames: number;\n}\n\nexport interface ChunkMetrics {\n  originalSize: number;\n  processedSize: number;\n  noiseRemoved: number;\n  metrics: ProcessingMetrics;\n  duration: number;\n  startTime: number;\n  endTime: number;\n}\n\nexport interface ChunkConfig {\n  chunkDuration: number;\n  onChunkProcessed?: (chunk: ChunkMetrics) => void;\n  overlap?: number;\n}\n\nexport interface DiagnosticInfo {\n  version: string;\n  engineVersion: string;\n  reactVersion: string;\n  browserInfo: {\n    name: string;\n    version: string;\n    audioAPIsSupported: string[];\n  };\n  wasmLoaded: boolean;\n  activeProcessors: number;\n  memoryUsage: number;\n  processingTime: number;\n  engineState: EngineState;\n  capabilities: {\n    hasWASM: boolean;\n    hasAudioContext: boolean;\n    hasWorklet: boolean;\n    maxChannels: number;\n  };\n  errors: Array<{ timestamp: number; error: string }>;\n  initializationLog: string[];\n  performanceMetrics: {\n    wasmLoadTime: number;\n    contextCreationTime: number;\n    totalInitTime: number;\n  };\n}\n\nexport interface EngineEvents {\n  initialized: () => void;\n  'processing-start': () => void;\n  'processing-end': () => void;\n  destroyed: () => void;\n  error: (error: MurmubaraError) => void;\n  'state-change': (oldState: EngineState, newState: EngineState) => void;\n  'metrics-update': (metrics: ProcessingMetrics) => void;\n  'degraded-mode': () => void;\n  [key: string]: (...args: any[]) => void;\n}\n\nexport class MurmubaraError extends Error {\n  code: string;\n  details?: any;\n\n  constructor(code: string, message: string, details?: any) {\n    super(message);\n    this.name = 'MurmubaraError';\n    this.code = code;\n    this.details = details;\n  }\n}\n\nexport interface DiagnosticReport {\n  timestamp: number;\n  tests: Array<{\n    name: string;\n    passed: boolean;\n    message: string;\n    duration: number;\n  }>;\n  passed: number;\n  failed: number;\n  warnings: number;\n}\n\nexport const ErrorCodes = {\n  WASM_NOT_LOADED: 'WASM_NOT_LOADED',\n  INVALID_STREAM: 'INVALID_STREAM',\n  ENGINE_BUSY: 'ENGINE_BUSY',\n  INITIALIZATION_FAILED: 'INITIALIZATION_FAILED',\n  PROCESSING_FAILED: 'PROCESSING_FAILED',\n  CLEANUP_FAILED: 'CLEANUP_FAILED',\n  WORKER_ERROR: 'WORKER_ERROR',\n  INVALID_CONFIG: 'INVALID_CONFIG',\n  NOT_INITIALIZED: 'NOT_INITIALIZED',\n  ALREADY_INITIALIZED: 'ALREADY_INITIALIZED',\n} as const;","import { Logger } from '../core/Logger';\nimport { MurmubaraError, ErrorCodes } from '../types';\n\ninterface WorkerMessage {\n  type: string;\n  payload?: any;\n}\n\nexport class WorkerManager {\n  private workers: Map<string, Worker> = new Map();\n  private logger: Logger;\n  \n  constructor(logger: Logger) {\n    this.logger = logger;\n  }\n  \n  createWorker(id: string, workerPath: string): Worker {\n    if (this.workers.has(id)) {\n      throw new MurmubaraError(\n        ErrorCodes.WORKER_ERROR,\n        `Worker with id ${id} already exists`\n      );\n    }\n    \n    try {\n      const worker = new Worker(workerPath);\n      this.workers.set(id, worker);\n      this.logger.debug(`Worker created: ${id}`);\n      return worker;\n    } catch (error) {\n      this.logger.error(`Failed to create worker: ${id}`, error);\n      throw new MurmubaraError(\n        ErrorCodes.WORKER_ERROR,\n        `Failed to create worker: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  }\n  \n  getWorker(id: string): Worker | undefined {\n    return this.workers.get(id);\n  }\n  \n  sendMessage(id: string, message: WorkerMessage): void {\n    const worker = this.workers.get(id);\n    if (!worker) {\n      throw new MurmubaraError(\n        ErrorCodes.WORKER_ERROR,\n        `Worker ${id} not found`\n      );\n    }\n    \n    worker.postMessage(message);\n    this.logger.debug(`Message sent to worker ${id}:`, message);\n  }\n  \n  terminateWorker(id: string): void {\n    const worker = this.workers.get(id);\n    if (worker) {\n      worker.terminate();\n      this.workers.delete(id);\n      this.logger.debug(`Worker terminated: ${id}`);\n    }\n  }\n  \n  terminateAll(): void {\n    this.logger.info(`Terminating all ${this.workers.size} workers`);\n    for (const [id, worker] of this.workers) {\n      worker.terminate();\n      this.logger.debug(`Worker terminated: ${id}`);\n    }\n    this.workers.clear();\n  }\n  \n  getActiveWorkerCount(): number {\n    return this.workers.size;\n  }\n  \n  getWorkerIds(): string[] {\n    return Array.from(this.workers.keys());\n  }\n}","import { ProcessingMetrics, ChunkMetrics } from '../types';\nimport { EventEmitter } from '../core/EventEmitter';\n\ninterface MetricsEvents {\n  'metrics-update': (metrics: ProcessingMetrics) => void;\n  'chunk-processed': (chunk: ChunkMetrics) => void;\n  [key: string]: (...args: any[]) => void;\n}\n\nexport class MetricsManager extends EventEmitter<MetricsEvents> {\n  private metrics: ProcessingMetrics = {\n    noiseReductionLevel: 0,\n    processingLatency: 0,\n    inputLevel: 0,\n    outputLevel: 0,\n    timestamp: Date.now(),\n    frameCount: 0,\n    droppedFrames: 0,\n  };\n  \n  private updateInterval?: NodeJS.Timeout;\n  private frameTimestamps: number[] = [];\n  private maxFrameHistory = 100;\n  \n  startAutoUpdate(intervalMs: number = 100): void {\n    this.stopAutoUpdate();\n    this.updateInterval = setInterval(() => {\n      this.calculateLatency();\n      this.emit('metrics-update', { ...this.metrics });\n    }, intervalMs);\n  }\n  \n  stopAutoUpdate(): void {\n    if (this.updateInterval) {\n      clearInterval(this.updateInterval);\n      this.updateInterval = undefined;\n    }\n  }\n  \n  updateInputLevel(level: number): void {\n    this.metrics.inputLevel = Math.max(0, Math.min(1, level));\n  }\n  \n  updateOutputLevel(level: number): void {\n    this.metrics.outputLevel = Math.max(0, Math.min(1, level));\n  }\n  \n  updateNoiseReduction(level: number): void {\n    this.metrics.noiseReductionLevel = Math.max(0, Math.min(100, level));\n  }\n  \n  recordFrame(timestamp: number = Date.now()): void {\n    this.frameTimestamps.push(timestamp);\n    if (this.frameTimestamps.length > this.maxFrameHistory) {\n      this.frameTimestamps.shift();\n    }\n    this.metrics.frameCount++;\n    this.metrics.timestamp = timestamp;\n  }\n  \n  recordDroppedFrame(): void {\n    this.metrics.droppedFrames++;\n  }\n  \n  recordChunk(chunk: ChunkMetrics): void {\n    this.emit('chunk-processed', chunk);\n  }\n  \n  private calculateLatency(): void {\n    if (this.frameTimestamps.length < 2) {\n      this.metrics.processingLatency = 0;\n      return;\n    }\n    \n    const deltas: number[] = [];\n    for (let i = 1; i < this.frameTimestamps.length; i++) {\n      deltas.push(this.frameTimestamps[i] - this.frameTimestamps[i - 1]);\n    }\n    \n    const avgDelta = deltas.reduce((a, b) => a + b, 0) / deltas.length;\n    this.metrics.processingLatency = avgDelta;\n  }\n  \n  getMetrics(): ProcessingMetrics {\n    return { ...this.metrics };\n  }\n  \n  reset(): void {\n    this.metrics = {\n      noiseReductionLevel: 0,\n      processingLatency: 0,\n      inputLevel: 0,\n      outputLevel: 0,\n      timestamp: Date.now(),\n      frameCount: 0,\n      droppedFrames: 0,\n    };\n    this.frameTimestamps = [];\n  }\n  \n  calculateRMS(samples: Float32Array): number {\n    let sum = 0;\n    for (let i = 0; i < samples.length; i++) {\n      sum += samples[i] * samples[i];\n    }\n    return Math.sqrt(sum / samples.length);\n  }\n  \n  calculatePeak(samples: Float32Array): number {\n    let peak = 0;\n    for (let i = 0; i < samples.length; i++) {\n      peak = Math.max(peak, Math.abs(samples[i]));\n    }\n    return peak;\n  }\n}","import { EventEmitter } from '../core/EventEmitter';\nimport { Logger } from '../core/Logger';\nimport { ChunkMetrics, ChunkConfig, ProcessingMetrics } from '../types';\nimport { MetricsManager } from './MetricsManager';\n\ninterface ChunkEvents {\n  'chunk-ready': (chunk: AudioChunk) => void;\n  'chunk-processed': (metrics: ChunkMetrics) => void;\n  [key: string]: (...args: any[]) => void;\n}\n\ninterface AudioChunk {\n  id: string;\n  data: Float32Array;\n  startTime: number;\n  endTime: number;\n  sampleRate: number;\n  channelCount: number;\n}\n\nexport class ChunkProcessor extends EventEmitter<ChunkEvents> {\n  private logger: Logger;\n  private config: Required<ChunkConfig>;\n  private currentChunk: Float32Array[] = [];\n  private chunkStartTime: number = Date.now();\n  private chunkIndex: number = 0;\n  private sampleRate: number;\n  private samplesPerChunk: number;\n  private currentSampleCount: number = 0;\n  private overlapBuffer: Float32Array[] = [];\n  private metricsManager: MetricsManager;\n  \n  constructor(\n    sampleRate: number,\n    config: ChunkConfig,\n    logger: Logger,\n    metricsManager: MetricsManager\n  ) {\n    super();\n    this.logger = logger;\n    this.sampleRate = sampleRate;\n    this.metricsManager = metricsManager;\n    \n    this.config = {\n      chunkDuration: config.chunkDuration,\n      onChunkProcessed: config.onChunkProcessed || undefined,\n      overlap: config.overlap || 0,\n    } as Required<ChunkConfig>;\n    \n    // Calculate samples per chunk\n    this.samplesPerChunk = Math.floor(\n      (this.config.chunkDuration / 1000) * this.sampleRate\n    );\n    \n    this.logger.info(`ChunkProcessor initialized:`, {\n      sampleRate: this.sampleRate,\n      chunkDuration: this.config.chunkDuration,\n      samplesPerChunk: this.samplesPerChunk,\n      overlap: this.config.overlap,\n    });\n  }\n  \n  /**\n   * Add samples to the current chunk\n   */\n  addSamples(samples: Float32Array): void {\n    // Initialize start time on first sample if not already set\n    if (this.chunkStartTime === 0) {\n      this.chunkStartTime = Date.now();\n    }\n    \n    this.currentChunk.push(new Float32Array(samples));\n    this.currentSampleCount += samples.length;\n    \n    // Check if we have enough samples for a chunk\n    while (this.currentSampleCount >= this.samplesPerChunk) {\n      this.processCurrentChunk();\n    }\n  }\n  \n  /**\n   * Process the current chunk\n   */\n  private processCurrentChunk(): void {\n    const chunkId = `chunk-${this.chunkIndex++}`;\n    const endTime = Date.now();\n    \n    // Combine all samples into a single array\n    const totalSamples = this.extractChunkSamples();\n    \n    // Apply overlap if configured\n    const processedSamples = this.applyOverlap(totalSamples);\n    \n    // Create chunk object\n    const chunk: AudioChunk = {\n      id: chunkId,\n      data: processedSamples,\n      startTime: this.chunkStartTime,\n      endTime: endTime,\n      sampleRate: this.sampleRate,\n      channelCount: 1,\n    };\n    \n    // Emit chunk ready event\n    this.emit('chunk-ready', chunk);\n    \n    // Calculate and emit metrics\n    this.emitChunkMetrics(chunk, totalSamples, processedSamples);\n    \n    // Reset for next chunk\n    this.chunkStartTime = endTime;\n  }\n  \n  /**\n   * Extract samples for current chunk\n   */\n  private extractChunkSamples(): Float32Array {\n    const result = new Float32Array(this.samplesPerChunk);\n    let offset = 0;\n    let remainingSamples = this.samplesPerChunk;\n    \n    while (remainingSamples > 0 && this.currentChunk.length > 0) {\n      const buffer = this.currentChunk[0];\n      const samplesToTake = Math.min(remainingSamples, buffer.length);\n      \n      // Copy samples\n      result.set(buffer.subarray(0, samplesToTake), offset);\n      offset += samplesToTake;\n      remainingSamples -= samplesToTake;\n      \n      if (samplesToTake === buffer.length) {\n        // Used entire buffer\n        this.currentChunk.shift();\n      } else {\n        // Partial buffer used, keep remainder\n        this.currentChunk[0] = buffer.subarray(samplesToTake);\n      }\n    }\n    \n    this.currentSampleCount -= this.samplesPerChunk;\n    return result;\n  }\n  \n  /**\n   * Apply overlap window to smooth chunk transitions\n   */\n  private applyOverlap(samples: Float32Array): Float32Array {\n    if (this.config.overlap === 0) {\n      return samples;\n    }\n    \n    const overlapSamples = Math.floor(this.samplesPerChunk * this.config.overlap);\n    const result = new Float32Array(samples.length);\n    \n    // Copy main samples\n    result.set(samples);\n    \n    // Apply overlap from previous chunk\n    if (this.overlapBuffer.length > 0) {\n      const previousOverlap = this.combineBuffers(this.overlapBuffer);\n      const fadeLength = Math.min(overlapSamples, previousOverlap.length);\n      \n      // Crossfade between chunks\n      for (let i = 0; i < fadeLength; i++) {\n        const fadeIn = i / fadeLength;\n        const fadeOut = 1 - fadeIn;\n        result[i] = result[i] * fadeIn + previousOverlap[i] * fadeOut;\n      }\n    }\n    \n    // Save overlap for next chunk\n    this.overlapBuffer = [samples.subarray(samples.length - overlapSamples)];\n    \n    return result;\n  }\n  \n  /**\n   * Calculate and emit chunk metrics\n   */\n  private emitChunkMetrics(\n    chunk: AudioChunk,\n    originalSamples: Float32Array,\n    processedSamples: Float32Array\n  ): void {\n    // Calculate metrics\n    const originalRMS = this.metricsManager.calculateRMS(originalSamples);\n    const processedRMS = this.metricsManager.calculateRMS(processedSamples);\n    const originalPeak = this.metricsManager.calculatePeak(originalSamples);\n    const processedPeak = this.metricsManager.calculatePeak(processedSamples);\n    \n    const noiseRemoved = originalRMS > 0 \n      ? ((originalRMS - processedRMS) / originalRMS) * 100 \n      : 0;\n    \n    const metrics: ChunkMetrics = {\n      originalSize: originalSamples.length * 4, // Float32 = 4 bytes\n      processedSize: processedSamples.length * 4,\n      noiseRemoved: Math.max(0, Math.min(100, noiseRemoved)),\n      metrics: {\n        noiseReductionLevel: noiseRemoved,\n        processingLatency: chunk.endTime - chunk.startTime,\n        inputLevel: originalPeak,\n        outputLevel: processedPeak,\n        timestamp: chunk.endTime,\n        frameCount: Math.floor(processedSamples.length / 480), // RNNoise frame size\n        droppedFrames: 0,\n      },\n      duration: this.config.chunkDuration,\n      startTime: chunk.startTime,\n      endTime: chunk.endTime,\n    };\n    \n    // Emit to listeners\n    this.emit('chunk-processed', metrics);\n    \n    // Call user callback if provided\n    if (this.config.onChunkProcessed) {\n      try {\n        this.config.onChunkProcessed(metrics);\n      } catch (error) {\n        this.logger.error('Error in chunk processed callback:', error);\n      }\n    }\n    \n    this.logger.debug(`Chunk ${chunk.id} processed:`, {\n      duration: `${metrics.duration}ms`,\n      noiseRemoved: `${metrics.noiseRemoved.toFixed(1)}%`,\n      latency: `${metrics.metrics.processingLatency}ms`,\n    });\n  }\n  \n  /**\n   * Force process remaining samples as final chunk\n   */\n  flush(): void {\n    if (this.currentSampleCount > 0) {\n      this.logger.info(`Flushing final chunk with ${this.currentSampleCount} samples`);\n      \n      // Pad with silence if needed\n      const remainingSamples = this.samplesPerChunk - this.currentSampleCount;\n      if (remainingSamples > 0) {\n        this.addSamples(new Float32Array(remainingSamples));\n      }\n      \n      this.processCurrentChunk();\n    }\n    \n    this.reset();\n  }\n  \n  /**\n   * Reset the processor\n   */\n  reset(): void {\n    this.currentChunk = [];\n    this.overlapBuffer = [];\n    this.currentSampleCount = 0;\n    this.chunkIndex = 0;\n    this.chunkStartTime = Date.now();\n    this.logger.debug('ChunkProcessor reset');\n  }\n  \n  /**\n   * Combine multiple buffers into one\n   */\n  private combineBuffers(buffers: Float32Array[]): Float32Array {\n    const totalLength = buffers.reduce((sum, buf) => sum + buf.length, 0);\n    const result = new Float32Array(totalLength);\n    let offset = 0;\n    \n    for (const buffer of buffers) {\n      result.set(buffer, offset);\n      offset += buffer.length;\n    }\n    \n    return result;\n  }\n  \n  /**\n   * Get current buffer status\n   */\n  getStatus(): {\n    currentSampleCount: number;\n    samplesPerChunk: number;\n    chunkIndex: number;\n    bufferFillPercentage: number;\n  } {\n    return {\n      currentSampleCount: this.currentSampleCount,\n      samplesPerChunk: this.samplesPerChunk,\n      chunkIndex: this.chunkIndex,\n      bufferFillPercentage: (this.currentSampleCount / this.samplesPerChunk) * 100,\n    };\n  }\n}","import { EventEmitter } from './EventEmitter';\nimport { StateManager } from './StateManager';\nimport { Logger } from './Logger';\nimport { WorkerManager } from '../managers/WorkerManager';\nimport { MetricsManager } from '../managers/MetricsManager';\nimport { ChunkProcessor } from '../managers/ChunkProcessor';\nimport {\n  MurmubaraConfig,\n  EngineEvents,\n  StreamController,\n  DiagnosticInfo,\n  DiagnosticReport,\n  MurmubaraError,\n  ErrorCodes,\n  ProcessingMetrics,\n  ChunkConfig,\n  EngineState,\n} from '../types';\n\nexport class MurmubaraEngine extends EventEmitter<EngineEvents> {\n  private config: Required<MurmubaraConfig>;\n  private stateManager: StateManager;\n  private logger: Logger;\n  private workerManager: WorkerManager;\n  private metricsManager: MetricsManager;\n  private audioContext?: AudioContext;\n  private activeStreams: Map<string, StreamController> = new Map();\n  private wasmModule?: any;\n  private rnnoiseState?: any;\n  private inputPtr?: number;\n  private outputPtr?: number;\n  private initPromise?: Promise<void>;\n  private cleanupTimer?: NodeJS.Timeout;\n  private errorHistory: Array<{ timestamp: number; error: string }> = [];\n  \n  constructor(config: MurmubaraConfig = {}) {\n    super();\n    \n    this.config = {\n      logLevel: config.logLevel || 'info',\n      onLog: config.onLog || undefined,\n      noiseReductionLevel: config.noiseReductionLevel || 'medium',\n      bufferSize: config.bufferSize || 4096,\n      algorithm: config.algorithm || 'rnnoise',\n      autoCleanup: config.autoCleanup ?? true,\n      cleanupDelay: config.cleanupDelay || 30000,\n      useWorker: config.useWorker ?? false,\n      workerPath: config.workerPath || '/murmuraba.worker.js',\n      allowDegraded: config.allowDegraded ?? false,\n    } as Required<MurmubaraConfig>;\n    \n    this.logger = new Logger('[Murmuraba]');\n    this.logger.setLevel(this.config.logLevel);\n    if (this.config.onLog) {\n      this.logger.setLogHandler(this.config.onLog);\n    }\n    \n    this.stateManager = new StateManager();\n    this.workerManager = new WorkerManager(this.logger);\n    this.metricsManager = new MetricsManager();\n    \n    this.setupEventForwarding();\n    this.setupAutoCleanup();\n  }\n  \n  private setupEventForwarding(): void {\n    this.stateManager.on('state-change', (oldState, newState) => {\n      this.logger.info(`State transition: ${oldState} -> ${newState}`);\n      this.emit('state-change', oldState, newState);\n    });\n    \n    this.metricsManager.on('metrics-update', (metrics) => {\n      this.emit('metrics-update', metrics);\n    });\n  }\n  \n  private setupAutoCleanup(): void {\n    if (!this.config.autoCleanup) return;\n    \n    const resetCleanupTimer = () => {\n      if (this.cleanupTimer) {\n        clearTimeout(this.cleanupTimer);\n      }\n      \n      if (this.activeStreams.size === 0 && this.stateManager.isInState('ready')) {\n        this.cleanupTimer = setTimeout(() => {\n          this.logger.info('Auto-cleanup triggered due to inactivity');\n          this.destroy();\n        }, this.config.cleanupDelay);\n      }\n    };\n    \n    this.on('processing-start', () => {\n      if (this.cleanupTimer) {\n        clearTimeout(this.cleanupTimer);\n        this.cleanupTimer = undefined;\n      }\n    });\n    \n    this.on('processing-end', resetCleanupTimer);\n  }\n  \n  async initialize(): Promise<void> {\n    if (this.initPromise) {\n      return this.initPromise;\n    }\n    \n    if (!this.stateManager.canTransitionTo('initializing')) {\n      throw new MurmubaraError(\n        ErrorCodes.ALREADY_INITIALIZED,\n        'Engine is already initialized or in an invalid state'\n      );\n    }\n    \n    this.initPromise = this.performInitialization();\n    return this.initPromise;\n  }\n  \n  private async performInitialization(): Promise<void> {\n    this.stateManager.transitionTo('initializing');\n    \n    try {\n      this.logger.info('Initializing Murmuraba engine...');\n      \n      // Check environment support first\n      if (!this.checkEnvironmentSupport()) {\n        throw new Error('Environment not supported: Missing required APIs');\n      }\n      \n      // Create audio context with fallbacks\n      this.stateManager.transitionTo('creating-context');\n      await this.initializeAudioContext();\n      \n      // Load WASM module with timeout\n      this.stateManager.transitionTo('loading-wasm');\n      await this.loadWasmModuleWithTimeout(5000);\n      \n      // Initialize metrics\n      this.metricsManager.startAutoUpdate(100);\n      \n      this.stateManager.transitionTo('ready');\n      this.emit('initialized');\n      this.logger.info('Murmuraba engine initialized successfully');\n      \n    } catch (error) {\n      this.stateManager.transitionTo('error');\n      this.recordError(error);\n      \n      const murmubaraError = new MurmubaraError(\n        ErrorCodes.INITIALIZATION_FAILED,\n        `Initialization failed: ${error instanceof Error ? error.message : String(error)}`,\n        error\n      );\n      this.emit('error', murmubaraError);\n      \n      // Try degraded mode if configured\n      if (this.config.allowDegraded) {\n        this.logger.warn('Attempting degraded mode initialization...');\n        await this.initializeDegraded();\n      } else {\n        throw murmubaraError;\n      }\n    }\n  }\n  \n  private checkEnvironmentSupport(): boolean {\n    // Check for required APIs\n    const hasAudioContext = !!(\n      window.AudioContext || \n      (window as any).webkitAudioContext\n    );\n    const hasWebAssembly = !!window.WebAssembly;\n    \n    if (!hasAudioContext) {\n      this.logger.error('AudioContext API not supported');\n    }\n    if (!hasWebAssembly) {\n      this.logger.error('WebAssembly not supported');\n    }\n    \n    return hasAudioContext && hasWebAssembly;\n  }\n  \n  private async initializeAudioContext(): Promise<void> {\n    try {\n      const AudioContextClass = window.AudioContext || (window as any).webkitAudioContext;\n      this.audioContext = new AudioContextClass({ sampleRate: 48000 });\n      \n      // Resume if suspended (for Chrome autoplay policy)\n      if (this.audioContext.state === 'suspended') {\n        await this.audioContext.resume();\n      }\n    } catch (error) {\n      throw new Error(`Failed to create AudioContext: ${error instanceof Error ? error.message : String(error)}`);\n    }\n  }\n  \n  private async loadWasmModuleWithTimeout(timeoutMs: number): Promise<void> {\n    const timeoutPromise = new Promise<never>((_, reject) => {\n      setTimeout(() => reject(new Error(`WASM loading timeout after ${timeoutMs}ms`)), timeoutMs);\n    });\n    \n    try {\n      await Promise.race([\n        this.loadWasmModule(),\n        timeoutPromise\n      ]);\n    } catch (error) {\n      if (error instanceof Error && error.message.includes('timeout')) {\n        this.logger.error('WASM module loading timed out');\n      }\n      throw error;\n    }\n  }\n  \n  private recordError(error: unknown): void {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    this.errorHistory.push({\n      timestamp: Date.now(),\n      error: errorMessage\n    });\n    \n    // Keep only last 10 errors\n    if (this.errorHistory.length > 10) {\n      this.errorHistory.shift();\n    }\n  }\n  \n  private async initializeDegraded(): Promise<void> {\n    this.logger.info('Initializing in degraded mode...');\n    this.stateManager.transitionTo('degraded');\n    \n    // Create minimal audio context\n    if (!this.audioContext) {\n      try {\n        await this.initializeAudioContext();\n      } catch {\n        this.logger.error('Failed to create audio context even in degraded mode');\n        return;\n      }\n    }\n    \n    // Engine will work but without noise reduction\n    this.emit('degraded-mode');\n    this.logger.warn('Engine running in degraded mode - noise reduction disabled');\n  }\n  \n  private async loadWasmModule(): Promise<void> {\n    this.logger.debug('Loading WASM module...');\n    \n    // Load the RNNoise script\n    const script = document.createElement('script');\n    script.src = '/rnnoise-fixed.js';\n    \n    await new Promise<void>((resolve, reject) => {\n      script.onload = () => resolve();\n      script.onerror = () => reject(new Error('Failed to load RNNoise script'));\n      document.head.appendChild(script);\n    });\n    \n    // Create WASM module\n    const createRNNWasmModule = (window as any).createRNNWasmModule;\n    if (!createRNNWasmModule) {\n      throw new Error('RNNoise WASM module creator not found');\n    }\n    \n    this.wasmModule = await createRNNWasmModule({\n      locateFile: (filename: string) => {\n        if (filename.endsWith('.wasm')) {\n          return `/dist/${filename}`;\n        }\n        return filename;\n      }\n    });\n    \n    // Create RNNoise state\n    this.rnnoiseState = this.wasmModule._rnnoise_create(0);\n    if (!this.rnnoiseState) {\n      throw new Error('Failed to create RNNoise state');\n    }\n    \n    // Allocate memory\n    this.inputPtr = this.wasmModule._malloc(480 * 4);\n    this.outputPtr = this.wasmModule._malloc(480 * 4);\n    \n    // Warm up the model\n    await this.warmupModel();\n    \n    this.logger.debug('WASM module loaded successfully');\n  }\n  \n  private async warmupModel(): Promise<void> {\n    this.logger.debug('Warming up noise reduction model...');\n    const silentFrame = new Float32Array(480);\n    \n    for (let i = 0; i < 10; i++) {\n      this.processFrame(silentFrame);\n    }\n  }\n  \n  private processFrame(frame: Float32Array): Float32Array {\n    if (!this.wasmModule || !this.rnnoiseState || !this.inputPtr || !this.outputPtr) {\n      throw new Error('WASM module not initialized');\n    }\n    \n    // Copy to WASM heap\n    this.wasmModule.HEAPF32.set(frame, this.inputPtr >> 2);\n    \n    // Process with RNNoise\n    this.wasmModule._rnnoise_process_frame(\n      this.rnnoiseState,\n      this.outputPtr,\n      this.inputPtr\n    );\n    \n    // Get output\n    const output = new Float32Array(480);\n    for (let i = 0; i < 480; i++) {\n      output[i] = this.wasmModule.HEAPF32[(this.outputPtr >> 2) + i];\n    }\n    \n    return output;\n  }\n  \n  async processStream(\n    stream: MediaStream,\n    chunkConfig?: ChunkConfig\n  ): Promise<StreamController> {\n    this.stateManager.requireState('ready', 'processing');\n    \n    const streamId = this.generateStreamId();\n    this.logger.info(`Processing stream ${streamId}`);\n    \n    try {\n      const controller = await this.createStreamController(stream, streamId, chunkConfig);\n      this.activeStreams.set(streamId, controller);\n      \n      if (this.activeStreams.size === 1) {\n        this.stateManager.transitionTo('processing');\n        this.emit('processing-start');\n      }\n      \n      return controller;\n      \n    } catch (error) {\n      const murmubaraError = new MurmubaraError(\n        ErrorCodes.PROCESSING_FAILED,\n        `Failed to process stream: ${error instanceof Error ? error.message : String(error)}`,\n        error\n      );\n      this.emit('error', murmubaraError);\n      throw murmubaraError;\n    }\n  }\n  \n  private async createStreamController(\n    stream: MediaStream,\n    streamId: string,\n    chunkConfig?: ChunkConfig\n  ): Promise<StreamController> {\n    if (!this.audioContext) {\n      throw new Error('Audio context not initialized');\n    }\n    \n    const source = this.audioContext.createMediaStreamSource(stream);\n    const destination = this.audioContext.createMediaStreamDestination();\n    const processor = this.audioContext.createScriptProcessor(this.config.bufferSize, 1, 1);\n    \n    // Create pre-filters for medical equipment noise\n    const notchFilter1 = this.audioContext.createBiquadFilter();\n    notchFilter1.type = 'notch';\n    notchFilter1.frequency.value = 1000; // Common medical equipment beep frequency\n    notchFilter1.Q.value = 30; // Narrow notch\n    \n    const notchFilter2 = this.audioContext.createBiquadFilter();\n    notchFilter2.type = 'notch';\n    notchFilter2.frequency.value = 2000; // Harmonics of beeps\n    notchFilter2.Q.value = 30;\n    \n    const highPassFilter = this.audioContext.createBiquadFilter();\n    highPassFilter.type = 'highpass';\n    highPassFilter.frequency.value = 80; // Remove low-frequency rumble from machines\n    highPassFilter.Q.value = 0.7;\n    \n    const lowShelfFilter = this.audioContext.createBiquadFilter();\n    lowShelfFilter.type = 'lowshelf';\n    lowShelfFilter.frequency.value = 200; // Reduce echo/room resonance\n    lowShelfFilter.gain.value = -3; // Gentle reduction\n    \n    let isPaused = false;\n    let isStopped = false;\n    const inputBuffer: number[] = [];\n    const outputBuffer: number[] = [];\n    \n    // Setup chunk processor if configured\n    let chunkProcessor: ChunkProcessor | undefined;\n    if (chunkConfig) {\n      chunkProcessor = new ChunkProcessor(\n        this.audioContext.sampleRate,\n        chunkConfig,\n        this.logger,\n        this.metricsManager\n      );\n      \n      // Forward chunk events\n      chunkProcessor.on('chunk-processed', (metrics) => {\n        this.logger.debug('Chunk processed:', metrics);\n        this.metricsManager.recordChunk(metrics);\n      });\n    }\n    \n    processor.onaudioprocess = (event) => {\n      if (isStopped || isPaused) {\n        event.outputBuffer.getChannelData(0).fill(0);\n        return;\n      }\n      \n      const input = event.inputBuffer.getChannelData(0);\n      const output = event.outputBuffer.getChannelData(0);\n      \n      // Update metrics\n      const inputLevel = this.metricsManager.calculateRMS(input);\n      const inputPeak = this.metricsManager.calculatePeak(input);\n      this.metricsManager.updateInputLevel(inputPeak);\n      \n      // Add to buffer\n      for (let i = 0; i < input.length; i++) {\n        inputBuffer.push(input[i]);\n      }\n      \n      // If using chunk processing, add samples to chunk processor\n      if (chunkProcessor && !isPaused && !isStopped) {\n        chunkProcessor.addSamples(input);\n      }\n      \n      // Process frames\n      let totalInputRMS = 0;\n      let totalOutputRMS = 0;\n      let framesProcessed = 0;\n      \n      while (inputBuffer.length >= 480) {\n        const frame = new Float32Array(inputBuffer.splice(0, 480));\n        const frameInputRMS = this.metricsManager.calculateRMS(frame);\n        \n        const processed = this.processFrame(frame);\n        const frameOutputRMS = this.metricsManager.calculateRMS(processed);\n        \n        // Apply noise reduction level adjustment\n        const reductionFactor = this.getReductionFactor();\n        for (let i = 0; i < processed.length; i++) {\n          processed[i] *= reductionFactor;\n          outputBuffer.push(processed[i]);\n        }\n        \n        // Accumulate RMS values for accurate noise reduction calculation\n        totalInputRMS += frameInputRMS;\n        totalOutputRMS += frameOutputRMS * reductionFactor; // Account for reduction factor\n        framesProcessed++;\n        \n        this.metricsManager.recordFrame();\n      }\n      \n      // Output processed audio\n      for (let i = 0; i < output.length; i++) {\n        if (outputBuffer.length > 0) {\n          output[i] = outputBuffer.shift()!;\n        } else {\n          output[i] = 0;\n        }\n      }\n      \n      // Update output metrics\n      const outputLevel = this.metricsManager.calculateRMS(output);\n      const outputPeak = this.metricsManager.calculatePeak(output);\n      this.metricsManager.updateOutputLevel(outputPeak);\n      \n      // Calculate noise reduction based on actual processed frames\n      if (framesProcessed > 0) {\n        const avgInputRMS = totalInputRMS / framesProcessed;\n        const avgOutputRMS = totalOutputRMS / framesProcessed;\n        const reduction = avgInputRMS > 0 ? Math.max(0, (1 - avgOutputRMS / avgInputRMS) * 100) : 0;\n        this.metricsManager.updateNoiseReduction(reduction);\n      }\n    };\n    \n    // Connect filters in chain: source -> filters -> processor -> destination\n    source.connect(highPassFilter);\n    highPassFilter.connect(notchFilter1);\n    notchFilter1.connect(notchFilter2);\n    notchFilter2.connect(lowShelfFilter);\n    lowShelfFilter.connect(processor);\n    processor.connect(destination);\n    \n    const controller: StreamController = {\n      stream: destination.stream,\n      processor: {\n        id: streamId,\n        state: 'processing',\n        inputNode: source,\n        outputNode: destination,\n      },\n      stop: () => {\n        isStopped = true;\n        \n        // Flush any remaining chunks\n        if (chunkProcessor) {\n          chunkProcessor.flush();\n        }\n        \n        processor.disconnect();\n        source.disconnect();\n        this.activeStreams.delete(streamId);\n        this.logger.info(`Stream ${streamId} stopped`);\n        \n        if (this.activeStreams.size === 0) {\n          this.stateManager.transitionTo('ready');\n          this.emit('processing-end');\n        }\n      },\n      pause: () => {\n        isPaused = true;\n        controller.processor.state = 'paused';\n        this.logger.debug(`Stream ${streamId} paused`);\n      },\n      resume: () => {\n        isPaused = false;\n        controller.processor.state = 'processing';\n        this.logger.debug(`Stream ${streamId} resumed`);\n      },\n      getState: () => controller.processor.state as EngineState,\n    };\n    \n    return controller;\n  }\n  \n  private getReductionFactor(): number {\n    switch (this.config.noiseReductionLevel) {\n      case 'low': return 0.9;\n      case 'medium': return 0.7;\n      case 'high': return 0.5;\n      case 'auto': return 0.7; // TODO: Implement auto adjustment\n      default: return 0.7;\n    }\n  }\n  \n  private generateStreamId(): string {\n    return `stream-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n  }\n  \n  async destroy(force: boolean = false): Promise<void> {\n    if (!this.stateManager.canTransitionTo('destroying')) {\n      if (force) {\n        this.logger.warn('Force destroying engine');\n      } else {\n        throw new MurmubaraError(\n          ErrorCodes.CLEANUP_FAILED,\n          'Cannot destroy engine in current state'\n        );\n      }\n    }\n    \n    this.stateManager.transitionTo('destroying');\n    this.logger.info('Destroying Murmuraba engine...');\n    \n    try {\n      // Stop all active streams\n      for (const [id, controller] of this.activeStreams) {\n        controller.stop();\n      }\n      this.activeStreams.clear();\n      \n      // Stop metrics\n      this.metricsManager.stopAutoUpdate();\n      \n      // Terminate workers\n      this.workerManager.terminateAll();\n      \n      // Clean up WASM\n      if (this.wasmModule) {\n        if (this.inputPtr) this.wasmModule._free(this.inputPtr);\n        if (this.outputPtr) this.wasmModule._free(this.outputPtr);\n        if (this.rnnoiseState) this.wasmModule._rnnoise_destroy(this.rnnoiseState);\n      }\n      \n      // Close audio context\n      if (this.audioContext && this.audioContext.state !== 'closed') {\n        await this.audioContext.close();\n      }\n      \n      // Clear timers\n      if (this.cleanupTimer) {\n        clearTimeout(this.cleanupTimer);\n      }\n      \n      // Remove all event listeners\n      this.removeAllListeners();\n      \n      this.stateManager.transitionTo('destroyed');\n      this.emit('destroyed');\n      this.logger.info('Murmuraba engine destroyed successfully');\n      \n    } catch (error) {\n      this.stateManager.transitionTo('error');\n      const murmubaraError = new MurmubaraError(\n        ErrorCodes.CLEANUP_FAILED,\n        `Cleanup failed: ${error instanceof Error ? error.message : String(error)}`,\n        error\n      );\n      this.emit('error', murmubaraError);\n      throw murmubaraError;\n    }\n  }\n  \n  getMetrics(): ProcessingMetrics {\n    return this.metricsManager.getMetrics();\n  }\n  \n  onMetricsUpdate(callback: (metrics: ProcessingMetrics) => void): void {\n    this.on('metrics-update', callback);\n  }\n  \n  getDiagnostics(): DiagnosticInfo {\n    const reactVersion = (window as any).React?.version || 'unknown';\n    const capabilities = {\n      hasWASM: !!window.WebAssembly,\n      hasAudioContext: !!(window.AudioContext || (window as any).webkitAudioContext),\n      hasWorklet: !!(window.AudioWorkletNode),\n      maxChannels: this.audioContext?.destination.maxChannelCount || 0,\n    };\n    \n    const browserInfo = {\n      name: this.getBrowserName(),\n      version: this.getBrowserVersion(),\n      audioAPIsSupported: this.getAudioAPIsSupported(),\n    };\n    \n    return {\n      version: '1.3.0',\n      engineVersion: '2.0.0',\n      reactVersion,\n      browserInfo,\n      wasmLoaded: !!this.wasmModule,\n      activeProcessors: this.activeStreams.size,\n      memoryUsage: (performance as any).memory?.usedJSHeapSize || 0,\n      processingTime: this.metricsManager.getMetrics().processingLatency,\n      engineState: this.stateManager.getState(),\n      capabilities,\n      errors: this.errorHistory,\n      initializationLog: [], // TODO: Implement log history tracking\n      performanceMetrics: {\n        wasmLoadTime: 0, // TODO: Track actual load times\n        contextCreationTime: 0,\n        totalInitTime: 0,\n      },\n    };\n  }\n  \n  private getBrowserName(): string {\n    const userAgent = navigator.userAgent;\n    if (userAgent.includes('Chrome')) return 'Chrome';\n    if (userAgent.includes('Firefox')) return 'Firefox';\n    if (userAgent.includes('Safari')) return 'Safari';\n    if (userAgent.includes('Edge')) return 'Edge';\n    return 'Unknown';\n  }\n  \n  private getBrowserVersion(): string {\n    const userAgent = navigator.userAgent;\n    const match = userAgent.match(/(Chrome|Firefox|Safari|Edge)\\/([\\d.]+)/);\n    return match ? match[2] : 'unknown';\n  }\n  \n  private getAudioAPIsSupported(): string[] {\n    const apis: string[] = [];\n    if (window.AudioContext || (window as any).webkitAudioContext) apis.push('AudioContext');\n    if (window.AudioWorkletNode) apis.push('AudioWorklet');\n    if ((window as any).webkitAudioContext) apis.push('webkitAudioContext');\n    if (window.MediaStream) apis.push('MediaStream');\n    if (window.MediaRecorder) apis.push('MediaRecorder');\n    return apis;\n  }\n  \n  async runDiagnosticTests(): Promise<DiagnosticReport> {\n    const report: DiagnosticReport = {\n      timestamp: Date.now(),\n      tests: [],\n      passed: 0,\n      failed: 0,\n      warnings: 0,\n    };\n    \n    // Test 1: Environment Support\n    const envTest = {\n      name: 'Environment Support',\n      passed: false,\n      message: '',\n      duration: 0,\n    };\n    const startEnv = Date.now();\n    if (this.checkEnvironmentSupport()) {\n      envTest.passed = true;\n      envTest.message = 'All required APIs are supported';\n    } else {\n      envTest.message = 'Missing required APIs';\n    }\n    envTest.duration = Date.now() - startEnv;\n    report.tests.push(envTest);\n    \n    // Test 2: Audio Context Creation\n    const audioTest = {\n      name: 'Audio Context Creation',\n      passed: false,\n      message: '',\n      duration: 0,\n    };\n    const startAudio = Date.now();\n    try {\n      if (!this.audioContext) {\n        await this.initializeAudioContext();\n      }\n      audioTest.passed = true;\n      audioTest.message = `Audio context created (state: ${this.audioContext?.state})`;\n    } catch (error) {\n      audioTest.message = `Failed: ${error instanceof Error ? error.message : String(error)}`;\n    }\n    audioTest.duration = Date.now() - startAudio;\n    report.tests.push(audioTest);\n    \n    // Test 3: WASM Module Loading\n    const wasmTest = {\n      name: 'WASM Module Loading',\n      passed: false,\n      message: '',\n      duration: 0,\n    };\n    const startWasm = Date.now();\n    if (this.wasmModule) {\n      wasmTest.passed = true;\n      wasmTest.message = 'WASM module already loaded';\n    } else {\n      wasmTest.message = 'WASM module not loaded (run initialize first)';\n    }\n    wasmTest.duration = Date.now() - startWasm;\n    report.tests.push(wasmTest);\n    \n    // Test 4: Frame Processing\n    const frameTest = {\n      name: 'Frame Processing',\n      passed: false,\n      message: '',\n      duration: 0,\n    };\n    const startFrame = Date.now();\n    try {\n      if (this.wasmModule && this.rnnoiseState) {\n        const testFrame = new Float32Array(480);\n        const output = this.processFrame(testFrame);\n        frameTest.passed = output.length === 480;\n        frameTest.message = frameTest.passed ? 'Frame processing successful' : 'Invalid output size';\n      } else {\n        frameTest.message = 'Engine not initialized';\n      }\n    } catch (error) {\n      frameTest.message = `Failed: ${error instanceof Error ? error.message : String(error)}`;\n    }\n    frameTest.duration = Date.now() - startFrame;\n    report.tests.push(frameTest);\n    \n    // Calculate totals\n    report.passed = report.tests.filter((t: any) => t.passed).length;\n    report.failed = report.tests.filter((t: any) => !t.passed).length;\n    \n    return report;\n  }\n}","import { MurmubaraEngine } from './core/MurmubaraEngine';\nimport { MurmubaraConfig } from './types';\n\nlet globalEngine: MurmubaraEngine | null = null;\n\nexport async function initializeAudioEngine(config?: MurmubaraConfig): Promise<void> {\n  if (globalEngine) {\n    throw new Error('Audio engine is already initialized. Call destroyEngine() first.');\n  }\n  \n  globalEngine = new MurmubaraEngine(config);\n  await globalEngine.initialize();\n}\n\nexport function getEngine(): MurmubaraEngine {\n  if (!globalEngine) {\n    throw new Error('Audio engine not initialized. Call initializeAudioEngine() first.');\n  }\n  return globalEngine;\n}\n\nexport async function processStream(stream: MediaStream) {\n  const engine = getEngine();\n  return engine.processStream(stream);\n}\n\nexport async function processStreamChunked(\n  stream: MediaStream,\n  config: {\n    chunkDuration: number;\n    onChunkProcessed?: (chunk: any) => void;\n  }\n) {\n  const engine = getEngine();\n  return engine.processStream(stream, config);\n}\n\nexport async function destroyEngine(options?: { force?: boolean }): Promise<void> {\n  if (!globalEngine) {\n    return;\n  }\n  \n  await globalEngine.destroy(options?.force || false);\n  globalEngine = null;\n}\n\nexport function getEngineStatus() {\n  if (!globalEngine) {\n    return 'uninitialized';\n  }\n  return globalEngine.getDiagnostics().engineState;\n}\n\nexport function getDiagnostics() {\n  const engine = getEngine();\n  return engine.getDiagnostics();\n}\n\nexport function onMetricsUpdate(callback: (metrics: any) => void) {\n  const engine = getEngine();\n  engine.onMetricsUpdate(callback);\n}","import React, { useEffect, useRef, useState, useCallback } from 'react';\nimport {\n  initializeAudioEngine,\n  destroyEngine,\n  processStream,\n  processStreamChunked,\n  getEngineStatus,\n  getDiagnostics,\n  onMetricsUpdate,\n} from '../api';\nimport {\n  MurmubaraConfig,\n  EngineState,\n  ProcessingMetrics,\n  StreamController,\n  DiagnosticInfo,\n  ChunkMetrics,\n} from '../types';\n\ninterface UseMurmubaraEngineOptions extends MurmubaraConfig {\n  autoInitialize?: boolean;\n  fallbackToManual?: boolean;\n  onInitError?: (error: Error) => void;\n  react19Mode?: boolean;\n}\n\ninterface UseMurmubaraEngineReturn {\n  // State\n  isInitialized: boolean;\n  isLoading: boolean;\n  error: string | null;\n  engineState: EngineState;\n  metrics: ProcessingMetrics | null;\n  diagnostics: DiagnosticInfo | null;\n  \n  // Actions\n  initialize: () => Promise<void>;\n  destroy: (force?: boolean) => Promise<void>;\n  processStream: (stream: MediaStream) => Promise<StreamController>;\n  processStreamChunked: (\n    stream: MediaStream,\n    config: {\n      chunkDuration: number;\n      onChunkProcessed?: (chunk: ChunkMetrics) => void;\n    }\n  ) => Promise<StreamController>;\n  \n  // Utility\n  getDiagnostics: () => DiagnosticInfo | null;\n  resetError: () => void;\n}\n\nexport function useMurmubaraEngine(\n  options: UseMurmubaraEngineOptions = {}\n): UseMurmubaraEngineReturn {\n  const { \n    autoInitialize = false, \n    fallbackToManual = false, \n    onInitError,\n    react19Mode = false,\n    ...config \n  } = options;\n  \n  // Detect React version\n  const reactVersion = React.version;\n  const isReact19 = reactVersion.startsWith('19') || react19Mode;\n  \n  const [isInitialized, setIsInitialized] = useState(false);\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  const [engineState, setEngineState] = useState<EngineState>('uninitialized');\n  const [metrics, setMetrics] = useState<ProcessingMetrics | null>(null);\n  const [diagnostics, setDiagnostics] = useState<DiagnosticInfo | null>(null);\n  \n  const metricsUnsubscribeRef = useRef<(() => void) | null>(null);\n  const initializePromiseRef = useRef<Promise<void> | null>(null);\n  \n  const initialize = useCallback(async () => {\n    if (initializePromiseRef.current) {\n      return initializePromiseRef.current;\n    }\n    \n    if (isInitialized) {\n      return;\n    }\n    \n    setIsLoading(true);\n    setError(null);\n    \n    initializePromiseRef.current = (async () => {\n      try {\n        await initializeAudioEngine(config);\n        \n        // Set up metrics listener\n        onMetricsUpdate((newMetrics: ProcessingMetrics) => {\n          setMetrics(newMetrics);\n        });\n        \n        setIsInitialized(true);\n        setEngineState('ready');\n        updateDiagnostics();\n        \n      } catch (err) {\n        const error = err instanceof Error ? err : new Error(String(err));\n        const errorMessage = error.message;\n        setError(errorMessage);\n        setEngineState('error');\n        \n        // Call error callback if provided\n        if (onInitError) {\n          onInitError(error);\n        }\n        \n        // If fallback is enabled and we're in React 19, try manual initialization\n        if (fallbackToManual && isReact19) {\n          console.warn('[MurmubaraEngine] Auto-init failed in React 19, attempting manual fallback');\n          // The user can still manually call initialize() later\n        } else {\n          throw err;\n        }\n      } finally {\n        setIsLoading(false);\n        initializePromiseRef.current = null;\n      }\n    })();\n    \n    return initializePromiseRef.current;\n  }, [config, isInitialized]);\n  \n  const destroy = useCallback(async (force: boolean = false) => {\n    if (!isInitialized) {\n      return;\n    }\n    \n    try {\n      await destroyEngine({ force });\n      setIsInitialized(false);\n      setEngineState('destroyed');\n      setMetrics(null);\n      setDiagnostics(null);\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : String(err);\n      setError(errorMessage);\n      throw err;\n    }\n  }, [isInitialized]);\n  \n  const processStreamWrapper = useCallback(async (stream: MediaStream) => {\n    if (!isInitialized) {\n      throw new Error('Engine not initialized');\n    }\n    \n    try {\n      const controller = await processStream(stream);\n      updateDiagnostics();\n      return controller;\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : String(err);\n      setError(errorMessage);\n      throw err;\n    }\n  }, [isInitialized]);\n  \n  const processStreamChunkedWrapper = useCallback(async (\n    stream: MediaStream,\n    chunkConfig: {\n      chunkDuration: number;\n      onChunkProcessed?: (chunk: ChunkMetrics) => void;\n    }\n  ) => {\n    if (!isInitialized) {\n      throw new Error('Engine not initialized');\n    }\n    \n    try {\n      const controller = await processStreamChunked(stream, chunkConfig);\n      updateDiagnostics();\n      return controller;\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : String(err);\n      setError(errorMessage);\n      throw err;\n    }\n  }, [isInitialized]);\n  \n  const updateDiagnostics = useCallback(() => {\n    if (!isInitialized) {\n      setDiagnostics(null);\n      return null;\n    }\n    \n    try {\n      const diag = getDiagnostics();\n      setDiagnostics(diag);\n      setEngineState(diag.engineState);\n      return diag;\n    } catch {\n      return null;\n    }\n  }, [isInitialized]);\n  \n  const resetError = useCallback(() => {\n    setError(null);\n  }, []);\n  \n  // Auto-initialize if requested\n  useEffect(() => {\n    if (autoInitialize && !isInitialized && !isLoading) {\n      initialize();\n    }\n  }, [autoInitialize, isInitialized, isLoading, initialize]);\n  \n  // Update engine state periodically\n  useEffect(() => {\n    if (!isInitialized) return;\n    \n    const interval = setInterval(() => {\n      try {\n        const status = getEngineStatus();\n        setEngineState(status as EngineState);\n      } catch {\n        // Engine might be destroyed\n      }\n    }, 1000);\n    \n    return () => clearInterval(interval);\n  }, [isInitialized]);\n  \n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      if (isInitialized) {\n        destroy(true).catch(console.error);\n      }\n    };\n  }, []);\n  \n  return {\n    // State\n    isInitialized,\n    isLoading,\n    error,\n    engineState,\n    metrics,\n    diagnostics,\n    \n    // Actions\n    initialize,\n    destroy,\n    processStream: processStreamWrapper,\n    processStreamChunked: processStreamChunkedWrapper,\n    \n    // Utility\n    getDiagnostics: updateDiagnostics,\n    resetError,\n  };\n}","import { AudioEngine } from './types';\n\nexport class RNNoiseEngine implements AudioEngine {\n  name = 'RNNoise';\n  description = 'Neural network-based noise suppression';\n  isInitialized = false;\n  \n  private module: any = null;\n  private state: any = null;\n  private inputPtr: number = 0;\n  private outputPtr: number = 0;\n  \n  async initialize(): Promise<void> {\n    if (this.isInitialized) return;\n    \n    console.log('[RNNoiseEngine] Starting initialization...');\n    \n    // Load script\n    const script = document.createElement('script');\n    script.src = '/rnnoise-fixed.js';\n    await new Promise((resolve, reject) => {\n      script.onload = resolve;\n      script.onerror = reject;\n      document.head.appendChild(script);\n    });\n    \n    // Create module\n    const createRNNWasmModule = (window as any).createRNNWasmModule;\n    this.module = await createRNNWasmModule({\n      locateFile: (filename: string) => {\n        if (filename.endsWith('.wasm')) {\n          return `/dist/${filename}`;\n        }\n        return filename;\n      }\n    });\n    \n    // Create state\n    this.state = this.module._rnnoise_create(0);\n    if (!this.state) {\n      throw new Error('Failed to create RNNoise state');\n    }\n    \n    // Allocate memory for float32 samples\n    this.inputPtr = this.module._malloc(480 * 4);\n    this.outputPtr = this.module._malloc(480 * 4);\n    \n    // Warm up\n    const silentFrame = new Float32Array(480);\n    for (let i = 0; i < 10; i++) {\n      this.module.HEAPF32.set(silentFrame, this.inputPtr >> 2);\n      this.module._rnnoise_process_frame(this.state, this.outputPtr, this.inputPtr);\n    }\n    \n    this.isInitialized = true;\n    console.log('[RNNoiseEngine] Initialization complete!');\n  }\n  \n  process(inputBuffer: Float32Array): Float32Array {\n    if (!this.isInitialized) {\n      throw new Error('RNNoiseEngine not initialized');\n    }\n    \n    if (inputBuffer.length !== 480) {\n      throw new Error('RNNoise requires exactly 480 samples per frame');\n    }\n    \n    // Copy to WASM heap\n    this.module.HEAPF32.set(inputBuffer, this.inputPtr >> 2);\n    \n    // Process with RNNoise\n    this.module._rnnoise_process_frame(\n      this.state, \n      this.outputPtr, \n      this.inputPtr\n    );\n    \n    // Get output\n    const outputData = new Float32Array(480);\n    for (let i = 0; i < 480; i++) {\n      outputData[i] = this.module.HEAPF32[(this.outputPtr >> 2) + i];\n    }\n    \n    return outputData;\n  }\n  \n  cleanup(): void {\n    if (this.module && this.state) {\n      this.module._free(this.inputPtr);\n      this.module._free(this.outputPtr);\n      this.module._rnnoise_destroy(this.state);\n      this.state = null;\n      this.module = null;\n      this.isInitialized = false;\n    }\n  }\n}","import { useEffect, useRef, useState } from 'react';\nimport { createAudioEngine, AudioEngine, AudioEngineConfig } from '../engines';\nimport { ProcessingMetrics } from '../engines/types';\n\nexport const useAudioEngine = (config: AudioEngineConfig = { engineType: 'rnnoise' }) => {\n  console.warn('[Murmuraba] useAudioEngine is deprecated. Please use useMurmubaraEngine instead for better React 19 compatibility.');\n  const [isInitialized, setIsInitialized] = useState(false);\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  const audioContextRef = useRef<AudioContext | null>(null);\n  const processorRef = useRef<ScriptProcessorNode | null>(null);\n  const engineRef = useRef<AudioEngine | null>(null);\n  const engineDataRef = useRef<any>(null);\n  const metricsRef = useRef<ProcessingMetrics>({\n    inputSamples: 0,\n    outputSamples: 0,\n    silenceFrames: 0,\n    activeFrames: 0,\n    totalInputEnergy: 0,\n    totalOutputEnergy: 0,\n    peakInput: 0,\n    peakOutput: 0,\n    startTime: 0,\n    totalFrames: 0\n  });\n\n  const initializeAudioEngine = async () => {\n    if (isInitialized || isLoading) return;\n    \n    setIsLoading(true);\n    setError(null);\n    \n    try {\n      console.log('[AudioEngine] Creating audio engine with config:', config);\n      \n      // Create engine instance\n      const engine = createAudioEngine(config);\n      await engine.initialize();\n      engineRef.current = engine;\n      \n      // Initialize engine-specific data\n      engineDataRef.current = {\n        inputBuffer: [],\n        outputBuffer: [],\n        energyHistory: new Array(20).fill(0),\n        energyIndex: 0\n      };\n      \n      console.log('[AudioEngine] Engine ready for processing');\n      \n      // Create audio context\n      audioContextRef.current = new AudioContext({ sampleRate: 48000 });\n      \n      // Create processor\n      const processor = audioContextRef.current.createScriptProcessor(4096, 1, 1);\n      \n      processor.onaudioprocess = (e) => {\n        const input = e.inputBuffer.getChannelData(0);\n        const output = e.outputBuffer.getChannelData(0);\n        \n        if (!engineRef.current || !engineDataRef.current) {\n          output.set(input);\n          return;\n        }\n        \n        // Track input metrics\n        metricsRef.current.inputSamples += input.length;\n        \n        // Add to input buffer\n        for (let i = 0; i < input.length; i++) {\n          engineDataRef.current.inputBuffer.push(input[i]);\n          metricsRef.current.peakInput = Math.max(metricsRef.current.peakInput, Math.abs(input[i]));\n        }\n        \n        // Process chunks of 480 samples\n        while (engineDataRef.current.inputBuffer.length >= 480) {\n          const frame = engineDataRef.current.inputBuffer.splice(0, 480);\n          const floatFrame = new Float32Array(frame);\n          \n          // Process with engine\n          const outputData = engineRef.current.process(floatFrame);\n          \n          // Calculate frame energy for gating\n          const frameEnergy = calculateRMS(floatFrame);\n          const outputEnergy = calculateRMS(outputData);\n          \n          // Track frame metrics\n          metricsRef.current.totalFrames++;\n          metricsRef.current.totalInputEnergy += frameEnergy;\n          metricsRef.current.totalOutputEnergy += outputEnergy;\n          \n          // Update energy history\n          engineDataRef.current.energyHistory[engineDataRef.current.energyIndex] = frameEnergy;\n          engineDataRef.current.energyIndex = (engineDataRef.current.energyIndex + 1) % 20;\n          \n          // Calculate average energy\n          const avgEnergy = engineDataRef.current.energyHistory.reduce((a: number, b: number) => a + b) / 20;\n          \n          // Simple energy-based gating\n          let processedFrame = outputData;\n          const silenceThreshold = 0.001;\n          const speechThreshold = 0.005;\n          let wasSilenced = false;\n          \n          if (avgEnergy < silenceThreshold) {\n            // Very quiet - attenuate heavily\n            processedFrame = processedFrame.map(s => s * 0.1);\n            wasSilenced = true;\n            metricsRef.current.silenceFrames++;\n          } else if (avgEnergy < speechThreshold) {\n            // Quiet - moderate attenuation\n            const factor = (avgEnergy - silenceThreshold) / (speechThreshold - silenceThreshold);\n            const attenuation = 0.1 + 0.9 * factor;\n            processedFrame = processedFrame.map(s => s * attenuation);\n            metricsRef.current.activeFrames++;\n          } else {\n            metricsRef.current.activeFrames++;\n          }\n          \n          // Additional noise gate based on RNNoise output vs input ratio\n          const reductionRatio = outputEnergy / (frameEnergy + 0.0001);\n          if (reductionRatio < 0.3 && avgEnergy < speechThreshold) {\n            // RNNoise reduced significantly - likely noise\n            processedFrame = processedFrame.map(s => s * reductionRatio);\n            if (!wasSilenced) metricsRef.current.silenceFrames++;\n          }\n          \n          // Log occasionally\n          if (Math.random() < 0.02) {\n            const gateStatus = avgEnergy < silenceThreshold ? 'SILENCE' : \n                             avgEnergy < speechThreshold ? 'TRANSITION' : 'SPEECH';\n            console.log('[AudioEngine]',\n                       '\\n  Status:', gateStatus,\n                       '\\n  Avg Energy:', avgEnergy.toFixed(6),\n                       '\\n  Frame Energy:', frameEnergy.toFixed(6),\n                       '\\n  Engine Reduction:', ((1 - reductionRatio) * 100).toFixed(1) + '%',\n                       '\\n  Gate Applied:', avgEnergy < speechThreshold ? 'Yes' : 'No');\n          }\n          \n          // Add to output buffer\n          for (let i = 0; i < 480; i++) {\n            engineDataRef.current.outputBuffer.push(processedFrame[i]);\n          }\n        }\n        \n        // Output\n        for (let i = 0; i < output.length; i++) {\n          if (engineDataRef.current.outputBuffer.length > 0) {\n            const sample = engineDataRef.current.outputBuffer.shift();\n            output[i] = sample;\n            metricsRef.current.outputSamples++;\n            metricsRef.current.peakOutput = Math.max(metricsRef.current.peakOutput, Math.abs(sample));\n          } else {\n            output[i] = 0;\n          }\n        }\n      };\n      \n      processorRef.current = processor;\n      setIsInitialized(true);\n      console.log('[AudioEngine] Initialization complete!');\n      \n    } catch (err) {\n      console.error('[AudioEngine] Error:', err);\n      setError(err instanceof Error ? err.message : String(err));\n      throw err;\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const resetMetrics = () => {\n    metricsRef.current = {\n      inputSamples: 0,\n      outputSamples: 0,\n      silenceFrames: 0,\n      activeFrames: 0,\n      totalInputEnergy: 0,\n      totalOutputEnergy: 0,\n      peakInput: 0,\n      peakOutput: 0,\n      startTime: Date.now(),\n      totalFrames: 0\n    };\n  };\n\n  const getMetrics = () => {\n    const metrics = metricsRef.current;\n    const processingTime = Date.now() - metrics.startTime;\n    const avgInputEnergy = metrics.totalFrames > 0 ? metrics.totalInputEnergy / metrics.totalFrames : 0;\n    const avgOutputEnergy = metrics.totalFrames > 0 ? metrics.totalOutputEnergy / metrics.totalFrames : 0;\n    \n    // Calculate noise reduction differently - compare silence frames to total frames\n    // and consider the energy reduction ratio\n    const energyReduction = avgInputEnergy > 0 ? Math.abs(avgInputEnergy - avgOutputEnergy) / avgInputEnergy : 0;\n    const silenceRatio = metrics.totalFrames > 0 ? metrics.silenceFrames / metrics.totalFrames : 0;\n    \n    // Combine both metrics for a more accurate noise reduction estimate\n    const noiseReduction = ((energyReduction * 0.5) + (silenceRatio * 0.5)) * 100;\n    \n    return {\n      inputSamples: metrics.inputSamples,\n      outputSamples: metrics.outputSamples,\n      noiseReductionLevel: Math.max(0, Math.min(100, noiseReduction)),\n      silenceFrames: metrics.silenceFrames,\n      activeFrames: metrics.activeFrames,\n      averageInputEnergy: avgInputEnergy,\n      averageOutputEnergy: avgOutputEnergy,\n      peakInputLevel: metrics.peakInput,\n      peakOutputLevel: metrics.peakOutput,\n      processingTimeMs: processingTime,\n      chunkOffset: 0,\n      totalFramesProcessed: metrics.totalFrames\n    };\n  };\n\n  const processStream = async (stream: MediaStream): Promise<MediaStream> => {\n    if (!isInitialized) {\n      await initializeAudioEngine();\n    }\n    \n    if (!audioContextRef.current || !processorRef.current) {\n      throw new Error('Not initialized');\n    }\n    \n    // Reset metrics when starting new stream\n    resetMetrics();\n    \n    const source = audioContextRef.current.createMediaStreamSource(stream);\n    const destination = audioContextRef.current.createMediaStreamDestination();\n    \n    source.connect(processorRef.current);\n    processorRef.current.connect(destination);\n    \n    return destination.stream;\n  };\n\n  const cleanup = () => {\n    if (processorRef.current) {\n      processorRef.current.disconnect();\n    }\n    if (engineRef.current) {\n      engineRef.current.cleanup();\n      engineRef.current = null;\n    }\n    if (audioContextRef.current && audioContextRef.current.state !== 'closed') {\n      audioContextRef.current.close();\n    }\n  };\n\n  return {\n    isInitialized,\n    isLoading,\n    error,\n    processStream,\n    cleanup,\n    initializeAudioEngine,\n    getMetrics,\n    resetMetrics\n  };\n};\n\nfunction calculateRMS(frame: Float32Array): number {\n  let sum = 0;\n  for (let i = 0; i < frame.length; i++) {\n    sum += frame[i] * frame[i];\n  }\n  return Math.sqrt(sum / frame.length);\n}","import { AudioEngine, AudioEngineConfig } from './types';\nimport { RNNoiseEngine } from './RNNoiseEngine';\n\nexport function createAudioEngine(config: AudioEngineConfig): AudioEngine {\n  switch (config.engineType) {\n    case 'rnnoise':\n      return new RNNoiseEngine();\n    case 'speex':\n      throw new Error('Speex engine not implemented yet');\n    case 'custom':\n      throw new Error('Custom engine not implemented yet');\n    default:\n      throw new Error(`Unknown engine type: ${config.engineType}`);\n  }\n}\n\nexport type { AudioEngine, AudioEngineConfig } from './types';","/**\n * Murmuraba v1.2.1\n * Real-time audio noise reduction with advanced chunked processing\n */\n\n// Core exports\nexport { MurmubaraEngine } from './core/MurmubaraEngine';\nexport { EventEmitter } from './core/EventEmitter';\nexport { StateManager } from './core/StateManager';\nexport { Logger } from './core/Logger';\n\n// Manager exports\nexport { WorkerManager } from './managers/WorkerManager';\nexport { MetricsManager } from './managers/MetricsManager';\n\n// Type exports\nexport * from './types';\n\n// Re-export API functions\nexport {\n  initializeAudioEngine,\n  getEngine,\n  processStream,\n  processStreamChunked,\n  destroyEngine,\n  getEngineStatus,\n  getDiagnostics,\n  onMetricsUpdate\n} from './api';\n\n// Export version\nexport const VERSION = '1.3.0';\nexport const MURMURABA_VERSION = VERSION;\n\n// Re-export error codes\nexport { ErrorCodes } from './types';\n\n// Hook exports at the end to avoid circular dependency\nexport { useMurmubaraEngine } from './hooks/useMurmubaraEngine';\nexport { useAudioEngine } from './hooks/useAudioEngine';\n\n// Import for default export\nimport { useMurmubaraEngine } from './hooks/useMurmubaraEngine';\nimport { useAudioEngine } from './hooks/useAudioEngine';\nimport { MurmubaraEngine } from './core/MurmubaraEngine';\n\n// Default export for easier usage\nexport default {\n  useMurmubaraEngine,\n  useAudioEngine,\n  MurmubaraEngine\n};"],"names":["EventEmitter","constructor","this","events","Map","on","event","handler","has","set","Set","get","add","off","handlers","delete","size","emit","args","forEach","error","console","String","once","wrappedHandler","removeAllListeners","clear","listenerCount","StateManager","currentState","allowedTransitions","getState","canTransitionTo","newState","includes","transitionTo","warn","oldState","isInState","states","requireState","Error","join","reset","Logger","prefix","level","setLevel","setLogHandler","onLog","shouldLog","levels","currentIndex","indexOf","messageIndex","log","message","data","timestamp","Date","toISOString","formattedMessage","toUpperCase","logMethod","undefined","info","debug","MurmubaraError","code","details","super","name","ErrorCodes","WASM_NOT_LOADED","INVALID_STREAM","ENGINE_BUSY","INITIALIZATION_FAILED","PROCESSING_FAILED","CLEANUP_FAILED","WORKER_ERROR","INVALID_CONFIG","NOT_INITIALIZED","ALREADY_INITIALIZED","WorkerManager","logger","workers","createWorker","id","workerPath","worker","Worker","getWorker","sendMessage","postMessage","terminateWorker","terminate","terminateAll","getActiveWorkerCount","getWorkerIds","Array","from","keys","MetricsManager","metrics","noiseReductionLevel","processingLatency","inputLevel","outputLevel","now","frameCount","droppedFrames","frameTimestamps","maxFrameHistory","startAutoUpdate","intervalMs","stopAutoUpdate","updateInterval","setInterval","calculateLatency","clearInterval","updateInputLevel","Math","max","min","updateOutputLevel","updateNoiseReduction","recordFrame","push","length","shift","recordDroppedFrame","recordChunk","chunk","deltas","i","avgDelta","reduce","a","b","getMetrics","calculateRMS","samples","sum","sqrt","calculatePeak","peak","abs","ChunkProcessor","sampleRate","config","metricsManager","currentChunk","chunkStartTime","chunkIndex","currentSampleCount","overlapBuffer","chunkDuration","onChunkProcessed","overlap","samplesPerChunk","floor","addSamples","Float32Array","processCurrentChunk","chunkId","endTime","totalSamples","extractChunkSamples","processedSamples","applyOverlap","startTime","channelCount","emitChunkMetrics","result","offset","remainingSamples","buffer","samplesToTake","subarray","overlapSamples","previousOverlap","combineBuffers","fadeLength","fadeIn","fadeOut","originalSamples","originalRMS","processedRMS","originalPeak","processedPeak","noiseRemoved","originalSize","processedSize","duration","toFixed","latency","flush","buffers","totalLength","buf","getStatus","bufferFillPercentage","MurmubaraEngine","activeStreams","errorHistory","logLevel","bufferSize","algorithm","autoCleanup","cleanupDelay","useWorker","allowDegraded","stateManager","workerManager","setupEventForwarding","setupAutoCleanup","cleanupTimer","clearTimeout","setTimeout","destroy","initialize","initPromise","performInitialization","checkEnvironmentSupport","initializeAudioContext","loadWasmModuleWithTimeout","recordError","murmubaraError","initializeDegraded","hasAudioContext","window","AudioContext","webkitAudioContext","hasWebAssembly","WebAssembly","AudioContextClass","audioContext","state","resume","timeoutMs","timeoutPromise","Promise","_","reject","race","loadWasmModule","errorMessage","script","document","createElement","src","resolve","onload","onerror","head","appendChild","createRNNWasmModule","wasmModule","locateFile","filename","endsWith","rnnoiseState","_rnnoise_create","inputPtr","_malloc","outputPtr","warmupModel","silentFrame","processFrame","frame","HEAPF32","_rnnoise_process_frame","output","processStream","stream","chunkConfig","streamId","generateStreamId","controller","createStreamController","source","createMediaStreamSource","destination","createMediaStreamDestination","processor","createScriptProcessor","notchFilter1","createBiquadFilter","type","frequency","value","Q","notchFilter2","highPassFilter","lowShelfFilter","gain","isPaused","isStopped","inputBuffer","outputBuffer","chunkProcessor","onaudioprocess","getChannelData","fill","input","inputPeak","totalInputRMS","totalOutputRMS","framesProcessed","splice","frameInputRMS","processed","frameOutputRMS","reductionFactor","getReductionFactor","outputPeak","avgInputRMS","avgOutputRMS","reduction","connect","inputNode","outputNode","stop","disconnect","pause","random","toString","substr","force","_free","_rnnoise_destroy","close","onMetricsUpdate","callback","getDiagnostics","reactVersion","React","version","capabilities","hasWASM","hasWorklet","maxChannels","maxChannelCount","engineVersion","browserInfo","getBrowserName","getBrowserVersion","audioAPIsSupported","getAudioAPIsSupported","wasmLoaded","activeProcessors","memoryUsage","performance","memory","usedJSHeapSize","processingTime","engineState","errors","initializationLog","performanceMetrics","wasmLoadTime","contextCreationTime","totalInitTime","userAgent","navigator","match","apis","AudioWorkletNode","MediaStream","MediaRecorder","runDiagnosticTests","report","tests","passed","failed","warnings","envTest","startEnv","audioTest","startAudio","wasmTest","startWasm","frameTest","startFrame","testFrame","filter","t","globalEngine","async","initializeAudioEngine","getEngine","processStreamChunked","destroyEngine","options","getEngineStatus","useMurmubaraEngine","autoInitialize","fallbackToManual","onInitError","react19Mode","isReact19","startsWith","isInitialized","setIsInitialized","useState","isLoading","setIsLoading","setError","setEngineState","setMetrics","diagnostics","setDiagnostics","useRef","initializePromiseRef","useCallback","current","newMetrics","updateDiagnostics","err","processStreamWrapper","processStreamChunkedWrapper","diag","resetError","useEffect","interval","status","catch","RNNoiseEngine","description","module","process","outputData","cleanup","useAudioEngine","engineType","audioContextRef","processorRef","engineRef","engineDataRef","metricsRef","inputSamples","outputSamples","silenceFrames","activeFrames","totalInputEnergy","totalOutputEnergy","peakInput","peakOutput","totalFrames","engine","createAudioEngine","energyHistory","energyIndex","e","floatFrame","frameEnergy","outputEnergy","avgEnergy","processedFrame","silenceThreshold","speechThreshold","wasSilenced","map","s","attenuation","reductionRatio","gateStatus","sample","resetMetrics","avgInputEnergy","avgOutputEnergy","noiseReduction","averageInputEnergy","averageOutputEnergy","peakInputLevel","peakOutputLevel","processingTimeMs","chunkOffset","totalFramesProcessed","VERSION","MURMURABA_VERSION","index"],"mappings":"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"}