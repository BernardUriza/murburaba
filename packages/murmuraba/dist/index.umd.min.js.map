{"version":3,"file":"index.umd.min.js","sources":["../src/engines/RNNoiseEngine.ts","../src/engines/index.ts","../src/hooks/useAudioEngine.ts","../src/utils/AudioStreamManager.ts","../src/index.ts","../src/utils/MurmurabaProcessor.ts"],"sourcesContent":["import { AudioEngine } from './types';\n\nexport class RNNoiseEngine implements AudioEngine {\n  name = 'RNNoise';\n  description = 'Neural network-based noise suppression';\n  isInitialized = false;\n  \n  private module: any = null;\n  private state: any = null;\n  private inputPtr: number = 0;\n  private outputPtr: number = 0;\n  \n  async initialize(): Promise<void> {\n    if (this.isInitialized) return;\n    \n    console.log('[RNNoiseEngine] Starting initialization...');\n    \n    // Load script\n    const script = document.createElement('script');\n    script.src = '/rnnoise-fixed.js';\n    await new Promise((resolve, reject) => {\n      script.onload = resolve;\n      script.onerror = reject;\n      document.head.appendChild(script);\n    });\n    \n    // Create module\n    const createRNNWasmModule = (window as any).createRNNWasmModule;\n    this.module = await createRNNWasmModule({\n      locateFile: (filename: string) => {\n        if (filename.endsWith('.wasm')) {\n          return `/dist/${filename}`;\n        }\n        return filename;\n      }\n    });\n    \n    // Create state\n    this.state = this.module._rnnoise_create(0);\n    if (!this.state) {\n      throw new Error('Failed to create RNNoise state');\n    }\n    \n    // Allocate memory for float32 samples\n    this.inputPtr = this.module._malloc(480 * 4);\n    this.outputPtr = this.module._malloc(480 * 4);\n    \n    // Warm up\n    const silentFrame = new Float32Array(480);\n    for (let i = 0; i < 10; i++) {\n      this.module.HEAPF32.set(silentFrame, this.inputPtr >> 2);\n      this.module._rnnoise_process_frame(this.state, this.outputPtr, this.inputPtr);\n    }\n    \n    this.isInitialized = true;\n    console.log('[RNNoiseEngine] Initialization complete!');\n  }\n  \n  process(inputBuffer: Float32Array): Float32Array {\n    if (!this.isInitialized) {\n      throw new Error('RNNoiseEngine not initialized');\n    }\n    \n    if (inputBuffer.length !== 480) {\n      throw new Error('RNNoise requires exactly 480 samples per frame');\n    }\n    \n    // Copy to WASM heap\n    this.module.HEAPF32.set(inputBuffer, this.inputPtr >> 2);\n    \n    // Process with RNNoise\n    this.module._rnnoise_process_frame(\n      this.state, \n      this.outputPtr, \n      this.inputPtr\n    );\n    \n    // Get output\n    const outputData = new Float32Array(480);\n    for (let i = 0; i < 480; i++) {\n      outputData[i] = this.module.HEAPF32[(this.outputPtr >> 2) + i];\n    }\n    \n    return outputData;\n  }\n  \n  cleanup(): void {\n    if (this.module && this.state) {\n      this.module._free(this.inputPtr);\n      this.module._free(this.outputPtr);\n      this.module._rnnoise_destroy(this.state);\n      this.state = null;\n      this.module = null;\n      this.isInitialized = false;\n    }\n  }\n}","import { AudioEngine, AudioEngineConfig } from './types';\nimport { RNNoiseEngine } from './RNNoiseEngine';\n\nexport function createAudioEngine(config: AudioEngineConfig): AudioEngine {\n  switch (config.engineType) {\n    case 'rnnoise':\n      return new RNNoiseEngine();\n    case 'speex':\n      throw new Error('Speex engine not implemented yet');\n    case 'custom':\n      throw new Error('Custom engine not implemented yet');\n    default:\n      throw new Error(`Unknown engine type: ${config.engineType}`);\n  }\n}\n\nexport { AudioEngine, AudioEngineConfig } from './types';","import { useEffect, useRef, useState } from 'react';\nimport { createAudioEngine, AudioEngine, AudioEngineConfig } from '../engines';\nimport { ProcessingMetrics } from '../engines/types';\n\nexport const useAudioEngine = (config: AudioEngineConfig = { engineType: 'rnnoise' }) => {\n  const [isInitialized, setIsInitialized] = useState(false);\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  const audioContextRef = useRef<AudioContext | null>(null);\n  const processorRef = useRef<ScriptProcessorNode | null>(null);\n  const engineRef = useRef<AudioEngine | null>(null);\n  const engineDataRef = useRef<any>(null);\n  const metricsRef = useRef<ProcessingMetrics>({\n    inputSamples: 0,\n    outputSamples: 0,\n    silenceFrames: 0,\n    activeFrames: 0,\n    totalInputEnergy: 0,\n    totalOutputEnergy: 0,\n    peakInput: 0,\n    peakOutput: 0,\n    startTime: 0,\n    totalFrames: 0\n  });\n\n  const initializeAudioEngine = async () => {\n    if (isInitialized || isLoading) return;\n    \n    setIsLoading(true);\n    setError(null);\n    \n    try {\n      console.log('[AudioEngine] Creating audio engine with config:', config);\n      \n      // Create engine instance\n      const engine = createAudioEngine(config);\n      await engine.initialize();\n      engineRef.current = engine;\n      \n      // Initialize engine-specific data\n      engineDataRef.current = {\n        inputBuffer: [],\n        outputBuffer: [],\n        energyHistory: new Array(20).fill(0),\n        energyIndex: 0\n      };\n      \n      console.log('[AudioEngine] Engine ready for processing');\n      \n      // Create audio context\n      audioContextRef.current = new AudioContext({ sampleRate: 48000 });\n      \n      // Create processor\n      const processor = audioContextRef.current.createScriptProcessor(4096, 1, 1);\n      \n      processor.onaudioprocess = (e) => {\n        const input = e.inputBuffer.getChannelData(0);\n        const output = e.outputBuffer.getChannelData(0);\n        \n        if (!engineRef.current || !engineDataRef.current) {\n          output.set(input);\n          return;\n        }\n        \n        // Track input metrics\n        metricsRef.current.inputSamples += input.length;\n        \n        // Add to input buffer\n        for (let i = 0; i < input.length; i++) {\n          engineDataRef.current.inputBuffer.push(input[i]);\n          metricsRef.current.peakInput = Math.max(metricsRef.current.peakInput, Math.abs(input[i]));\n        }\n        \n        // Process chunks of 480 samples\n        while (engineDataRef.current.inputBuffer.length >= 480) {\n          const frame = engineDataRef.current.inputBuffer.splice(0, 480);\n          const floatFrame = new Float32Array(frame);\n          \n          // Process with engine\n          const outputData = engineRef.current.process(floatFrame);\n          \n          // Calculate frame energy for gating\n          const frameEnergy = calculateRMS(floatFrame);\n          const outputEnergy = calculateRMS(outputData);\n          \n          // Track frame metrics\n          metricsRef.current.totalFrames++;\n          metricsRef.current.totalInputEnergy += frameEnergy;\n          metricsRef.current.totalOutputEnergy += outputEnergy;\n          \n          // Update energy history\n          engineDataRef.current.energyHistory[engineDataRef.current.energyIndex] = frameEnergy;\n          engineDataRef.current.energyIndex = (engineDataRef.current.energyIndex + 1) % 20;\n          \n          // Calculate average energy\n          const avgEnergy = engineDataRef.current.energyHistory.reduce((a: number, b: number) => a + b) / 20;\n          \n          // Simple energy-based gating\n          let processedFrame = outputData;\n          const silenceThreshold = 0.001;\n          const speechThreshold = 0.005;\n          let wasSilenced = false;\n          \n          if (avgEnergy < silenceThreshold) {\n            // Very quiet - attenuate heavily\n            processedFrame = processedFrame.map(s => s * 0.1);\n            wasSilenced = true;\n            metricsRef.current.silenceFrames++;\n          } else if (avgEnergy < speechThreshold) {\n            // Quiet - moderate attenuation\n            const factor = (avgEnergy - silenceThreshold) / (speechThreshold - silenceThreshold);\n            const attenuation = 0.1 + 0.9 * factor;\n            processedFrame = processedFrame.map(s => s * attenuation);\n            metricsRef.current.activeFrames++;\n          } else {\n            metricsRef.current.activeFrames++;\n          }\n          \n          // Additional noise gate based on RNNoise output vs input ratio\n          const reductionRatio = outputEnergy / (frameEnergy + 0.0001);\n          if (reductionRatio < 0.3 && avgEnergy < speechThreshold) {\n            // RNNoise reduced significantly - likely noise\n            processedFrame = processedFrame.map(s => s * reductionRatio);\n            if (!wasSilenced) metricsRef.current.silenceFrames++;\n          }\n          \n          // Log occasionally\n          if (Math.random() < 0.02) {\n            const gateStatus = avgEnergy < silenceThreshold ? 'SILENCE' : \n                             avgEnergy < speechThreshold ? 'TRANSITION' : 'SPEECH';\n            console.log('[AudioEngine]',\n                       '\\n  Status:', gateStatus,\n                       '\\n  Avg Energy:', avgEnergy.toFixed(6),\n                       '\\n  Frame Energy:', frameEnergy.toFixed(6),\n                       '\\n  Engine Reduction:', ((1 - reductionRatio) * 100).toFixed(1) + '%',\n                       '\\n  Gate Applied:', avgEnergy < speechThreshold ? 'Yes' : 'No');\n          }\n          \n          // Add to output buffer\n          for (let i = 0; i < 480; i++) {\n            engineDataRef.current.outputBuffer.push(processedFrame[i]);\n          }\n        }\n        \n        // Output\n        for (let i = 0; i < output.length; i++) {\n          if (engineDataRef.current.outputBuffer.length > 0) {\n            const sample = engineDataRef.current.outputBuffer.shift();\n            output[i] = sample;\n            metricsRef.current.outputSamples++;\n            metricsRef.current.peakOutput = Math.max(metricsRef.current.peakOutput, Math.abs(sample));\n          } else {\n            output[i] = 0;\n          }\n        }\n      };\n      \n      processorRef.current = processor;\n      setIsInitialized(true);\n      console.log('[AudioEngine] Initialization complete!');\n      \n    } catch (err) {\n      console.error('[AudioEngine] Error:', err);\n      setError(err instanceof Error ? err.message : String(err));\n      throw err;\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const resetMetrics = () => {\n    metricsRef.current = {\n      inputSamples: 0,\n      outputSamples: 0,\n      silenceFrames: 0,\n      activeFrames: 0,\n      totalInputEnergy: 0,\n      totalOutputEnergy: 0,\n      peakInput: 0,\n      peakOutput: 0,\n      startTime: Date.now(),\n      totalFrames: 0\n    };\n  };\n\n  const getMetrics = () => {\n    const metrics = metricsRef.current;\n    const processingTime = Date.now() - metrics.startTime;\n    const avgInputEnergy = metrics.totalFrames > 0 ? metrics.totalInputEnergy / metrics.totalFrames : 0;\n    const avgOutputEnergy = metrics.totalFrames > 0 ? metrics.totalOutputEnergy / metrics.totalFrames : 0;\n    \n    // Calculate noise reduction differently - compare silence frames to total frames\n    // and consider the energy reduction ratio\n    const energyReduction = avgInputEnergy > 0 ? Math.abs(avgInputEnergy - avgOutputEnergy) / avgInputEnergy : 0;\n    const silenceRatio = metrics.totalFrames > 0 ? metrics.silenceFrames / metrics.totalFrames : 0;\n    \n    // Combine both metrics for a more accurate noise reduction estimate\n    const noiseReduction = ((energyReduction * 0.5) + (silenceRatio * 0.5)) * 100;\n    \n    return {\n      inputSamples: metrics.inputSamples,\n      outputSamples: metrics.outputSamples,\n      noiseReductionLevel: Math.max(0, Math.min(100, noiseReduction)),\n      silenceFrames: metrics.silenceFrames,\n      activeFrames: metrics.activeFrames,\n      averageInputEnergy: avgInputEnergy,\n      averageOutputEnergy: avgOutputEnergy,\n      peakInputLevel: metrics.peakInput,\n      peakOutputLevel: metrics.peakOutput,\n      processingTimeMs: processingTime,\n      chunkOffset: 0,\n      totalFramesProcessed: metrics.totalFrames\n    };\n  };\n\n  const processStream = async (stream: MediaStream): Promise<MediaStream> => {\n    if (!isInitialized) {\n      await initializeAudioEngine();\n    }\n    \n    if (!audioContextRef.current || !processorRef.current) {\n      throw new Error('Not initialized');\n    }\n    \n    // Reset metrics when starting new stream\n    resetMetrics();\n    \n    const source = audioContextRef.current.createMediaStreamSource(stream);\n    const destination = audioContextRef.current.createMediaStreamDestination();\n    \n    source.connect(processorRef.current);\n    processorRef.current.connect(destination);\n    \n    return destination.stream;\n  };\n\n  const cleanup = () => {\n    if (processorRef.current) {\n      processorRef.current.disconnect();\n    }\n    if (engineRef.current) {\n      engineRef.current.cleanup();\n      engineRef.current = null;\n    }\n    if (audioContextRef.current && audioContextRef.current.state !== 'closed') {\n      audioContextRef.current.close();\n    }\n  };\n\n  return {\n    isInitialized,\n    isLoading,\n    error,\n    processStream,\n    cleanup,\n    initializeAudioEngine,\n    getMetrics,\n    resetMetrics\n  };\n};\n\nfunction calculateRMS(frame: Float32Array): number {\n  let sum = 0;\n  for (let i = 0; i < frame.length; i++) {\n    sum += frame[i] * frame[i];\n  }\n  return Math.sqrt(sum / frame.length);\n}","export class AudioStreamManager {\n  private streams: Map<string, MediaStream> = new Map();\n  private sources: Map<string, MediaStreamAudioSourceNode> = new Map();\n  \n  constructor(private audioContext: AudioContext) {}\n\n  addStream(id: string, stream: MediaStream): MediaStreamAudioSourceNode {\n    if (this.streams.has(id)) {\n      this.removeStream(id);\n    }\n    \n    this.streams.set(id, stream);\n    const source = this.audioContext.createMediaStreamSource(stream);\n    this.sources.set(id, source);\n    \n    return source;\n  }\n\n  getStream(id: string): MediaStream | undefined {\n    return this.streams.get(id);\n  }\n\n  getSource(id: string): MediaStreamAudioSourceNode | undefined {\n    return this.sources.get(id);\n  }\n\n  removeStream(id: string): void {\n    const stream = this.streams.get(id);\n    if (stream) {\n      stream.getTracks().forEach(track => track.stop());\n      this.streams.delete(id);\n    }\n    \n    const source = this.sources.get(id);\n    if (source) {\n      source.disconnect();\n      this.sources.delete(id);\n    }\n  }\n\n  removeAllStreams(): void {\n    const ids = Array.from(this.streams.keys());\n    ids.forEach(id => this.removeStream(id));\n  }\n\n  get size(): number {\n    return this.streams.size;\n  }\n}","// Main exports\nexport { useAudioEngine } from './hooks/useAudioEngine';\n\n// Engine exports\nexport { createAudioEngine } from './engines';\nexport { RNNoiseEngine } from './engines/RNNoiseEngine';\n\n// Type exports\nexport type { \n  AudioEngine, \n  AudioEngineConfig, \n  ProcessingMetrics \n} from './engines/types';\n\n// Utils exports\nexport { MurmurabaProcessor } from './utils/MurmurabaProcessor';\nexport { AudioStreamManager } from './utils/AudioStreamManager';\n\n// Constants\nexport const MURMURABA_VERSION = '0.1.0';\nexport const SUPPORTED_ENGINES = ['rnnoise', 'speex', 'custom'] as const;\nexport type SupportedEngine = typeof SUPPORTED_ENGINES[number];","import { AudioEngine, ProcessingMetrics } from '../engines/types';\n\nexport class MurmurabaProcessor {\n  private audioContext: AudioContext | null = null;\n  private processor: ScriptProcessorNode | null = null;\n  private engine: AudioEngine | null = null;\n  private inputBuffer: number[] = [];\n  private outputBuffer: number[] = [];\n  private metrics: ProcessingMetrics = {\n    inputSamples: 0,\n    outputSamples: 0,\n    silenceFrames: 0,\n    activeFrames: 0,\n    totalInputEnergy: 0,\n    totalOutputEnergy: 0,\n    peakInput: 0,\n    peakOutput: 0,\n    startTime: Date.now(),\n    totalFrames: 0\n  };\n\n  constructor(private frameSize: number = 480) {}\n\n  async initialize(engine: AudioEngine, sampleRate: number = 48000): Promise<void> {\n    if (!engine.isInitialized) {\n      await engine.initialize();\n    }\n    \n    this.engine = engine;\n    this.audioContext = new AudioContext({ sampleRate });\n    this.processor = this.audioContext.createScriptProcessor(4096, 1, 1);\n    \n    this.processor.onaudioprocess = (e) => this.processAudio(e);\n  }\n\n  private processAudio(e: AudioProcessingEvent): void {\n    if (!this.engine) return;\n\n    const input = e.inputBuffer.getChannelData(0);\n    const output = e.outputBuffer.getChannelData(0);\n    \n    // Add to input buffer\n    for (let i = 0; i < input.length; i++) {\n      this.inputBuffer.push(input[i]);\n      this.metrics.inputSamples++;\n      this.metrics.peakInput = Math.max(this.metrics.peakInput, Math.abs(input[i]));\n    }\n    \n    // Process frames\n    while (this.inputBuffer.length >= this.frameSize) {\n      const frame = new Float32Array(this.inputBuffer.splice(0, this.frameSize));\n      const processedFrame = this.engine.process(frame);\n      \n      // Update metrics\n      this.metrics.totalFrames++;\n      const inputEnergy = this.calculateRMS(frame);\n      const outputEnergy = this.calculateRMS(processedFrame);\n      this.metrics.totalInputEnergy += inputEnergy;\n      this.metrics.totalOutputEnergy += outputEnergy;\n      \n      if (outputEnergy < 0.001) {\n        this.metrics.silenceFrames++;\n      } else {\n        this.metrics.activeFrames++;\n      }\n      \n      // Add to output buffer\n      for (let i = 0; i < processedFrame.length; i++) {\n        this.outputBuffer.push(processedFrame[i]);\n      }\n    }\n    \n    // Output\n    for (let i = 0; i < output.length; i++) {\n      if (this.outputBuffer.length > 0) {\n        const sample = this.outputBuffer.shift()!;\n        output[i] = sample;\n        this.metrics.outputSamples++;\n        this.metrics.peakOutput = Math.max(this.metrics.peakOutput, Math.abs(sample));\n      } else {\n        output[i] = 0;\n      }\n    }\n  }\n\n  private calculateRMS(frame: Float32Array): number {\n    let sum = 0;\n    for (let i = 0; i < frame.length; i++) {\n      sum += frame[i] * frame[i];\n    }\n    return Math.sqrt(sum / frame.length);\n  }\n\n  connectStream(stream: MediaStream): MediaStreamAudioDestinationNode {\n    if (!this.audioContext || !this.processor) {\n      throw new Error('Processor not initialized');\n    }\n    \n    const source = this.audioContext.createMediaStreamSource(stream);\n    const destination = this.audioContext.createMediaStreamDestination();\n    \n    source.connect(this.processor);\n    this.processor.connect(destination);\n    \n    return destination;\n  }\n\n  getMetrics(): ProcessingMetrics {\n    return { ...this.metrics };\n  }\n\n  resetMetrics(): void {\n    this.metrics = {\n      inputSamples: 0,\n      outputSamples: 0,\n      silenceFrames: 0,\n      activeFrames: 0,\n      totalInputEnergy: 0,\n      totalOutputEnergy: 0,\n      peakInput: 0,\n      peakOutput: 0,\n      startTime: Date.now(),\n      totalFrames: 0\n    };\n  }\n\n  cleanup(): void {\n    if (this.processor) {\n      this.processor.disconnect();\n      this.processor = null;\n    }\n    if (this.audioContext && this.audioContext.state !== 'closed') {\n      this.audioContext.close();\n      this.audioContext = null;\n    }\n    if (this.engine) {\n      this.engine.cleanup();\n      this.engine = null;\n    }\n  }\n}"],"names":["RNNoiseEngine","constructor","this","name","description","isInitialized","module","state","inputPtr","outputPtr","initialize","console","log","script","document","createElement","src","Promise","resolve","reject","onload","onerror","head","appendChild","createRNNWasmModule","window","locateFile","filename","endsWith","_rnnoise_create","Error","_malloc","silentFrame","Float32Array","i","HEAPF32","set","_rnnoise_process_frame","process","inputBuffer","length","outputData","cleanup","_free","_rnnoise_destroy","createAudioEngine","config","engineType","calculateRMS","frame","sum","Math","sqrt","audioContext","streams","Map","sources","addStream","id","stream","has","removeStream","source","createMediaStreamSource","getStream","get","getSource","getTracks","forEach","track","stop","delete","disconnect","removeAllStreams","Array","from","keys","size","frameSize","processor","engine","outputBuffer","metrics","inputSamples","outputSamples","silenceFrames","activeFrames","totalInputEnergy","totalOutputEnergy","peakInput","peakOutput","startTime","Date","now","totalFrames","sampleRate","AudioContext","createScriptProcessor","onaudioprocess","e","processAudio","input","getChannelData","output","push","max","abs","splice","processedFrame","inputEnergy","outputEnergy","sample","shift","connectStream","destination","createMediaStreamDestination","connect","getMetrics","resetMetrics","close","setIsInitialized","useState","isLoading","setIsLoading","error","setError","audioContextRef","useRef","processorRef","engineRef","engineDataRef","metricsRef","initializeAudioEngine","async","current","energyHistory","fill","energyIndex","floatFrame","frameEnergy","avgEnergy","reduce","a","b","silenceThreshold","speechThreshold","wasSilenced","map","s","attenuation","reductionRatio","random","gateStatus","toFixed","err","message","String","processStream","processingTime","avgInputEnergy","avgOutputEnergy","noiseReduction","noiseReductionLevel","min","averageInputEnergy","averageOutputEnergy","peakInputLevel","peakOutputLevel","processingTimeMs","chunkOffset","totalFramesProcessed"],"mappings":"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"}