!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("react")):"function"==typeof define&&define.amd?define(["exports","react"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).Murmuraba={},e.React)}(this,function(e,t){"use strict";class r{constructor(){this.events=new Map}on(e,t){this.events.has(e)||this.events.set(e,new Set),this.events.get(e).add(t)}off(e,t){const r=this.events.get(e);r&&(r.delete(t),0===r.size&&this.events.delete(e))}emit(e,...t){const r=this.events.get(e);r&&r.forEach(r=>{try{r(...t)}catch(t){console.error(`Error in event handler for ${String(e)}:`,t)}})}once(e,t){const r=(...s)=>{this.off(e,r),t(...s)};this.on(e,r)}removeAllListeners(e){e?this.events.delete(e):this.events.clear()}listenerCount(e){const t=this.events.get(e);return t?t.size:0}}class s extends r{constructor(){super(...arguments),this.currentState="uninitialized",this.allowedTransitions=new Map([["uninitialized",["initializing","error"]],["initializing",["ready","error"]],["ready",["processing","destroying","error"]],["processing",["ready","paused","destroying","error"]],["paused",["processing","ready","destroying","error"]],["destroying",["destroyed","error"]],["destroyed",[]],["error",["initializing","destroying"]]])}getState(){return this.currentState}canTransitionTo(e){return(this.allowedTransitions.get(this.currentState)||[]).includes(e)}transitionTo(e){if(!this.canTransitionTo(e))return console.warn(`Invalid state transition: ${this.currentState} -> ${e}`),!1;const t=this.currentState;return this.currentState=e,this.emit("state-change",t,e),!0}isInState(...e){return e.includes(this.currentState)}requireState(...e){if(!this.isInState(...e))throw new Error(`Operation requires state to be one of: ${e.join(", ")}, but current state is: ${this.currentState}`)}reset(){const e=this.currentState;this.currentState="uninitialized","uninitialized"!==e&&this.emit("state-change",e,"uninitialized")}}class i{constructor(e="[Murmuraba]"){this.level="info",this.prefix=e}setLevel(e){this.level=e}setLogHandler(e){this.onLog=e}shouldLog(e){const t=["none","error","warn","info","debug"],r=t.indexOf(this.level),s=t.indexOf(e);return r>0&&s<=r}log(e,t,r){if(!this.shouldLog(e))return;const s=(new Date).toISOString(),i=`${this.prefix} [${s}] [${e.toUpperCase()}] ${t}`;if(this.onLog)this.onLog(e,i,r);else{const t="error"===e?console.error:"warn"===e?console.warn:console.log;void 0!==r?t(i,r):t(i)}}error(e,t){this.log("error",e,t)}warn(e,t){this.log("warn",e,t)}info(e,t){this.log("info",e,t)}debug(e,t){this.log("debug",e,t)}}class n extends Error{constructor(e,t,r){super(t),this.name="MurmubaraError",this.code=e,this.details=r}}const a={WASM_NOT_LOADED:"WASM_NOT_LOADED",INVALID_STREAM:"INVALID_STREAM",ENGINE_BUSY:"ENGINE_BUSY",INITIALIZATION_FAILED:"INITIALIZATION_FAILED",PROCESSING_FAILED:"PROCESSING_FAILED",CLEANUP_FAILED:"CLEANUP_FAILED",WORKER_ERROR:"WORKER_ERROR",INVALID_CONFIG:"INVALID_CONFIG",NOT_INITIALIZED:"NOT_INITIALIZED",ALREADY_INITIALIZED:"ALREADY_INITIALIZED"};class o{constructor(e){this.workers=new Map,this.logger=e}createWorker(e,t){if(this.workers.has(e))throw new n(a.WORKER_ERROR,`Worker with id ${e} already exists`);try{const r=new Worker(t);return this.workers.set(e,r),this.logger.debug(`Worker created: ${e}`),r}catch(t){throw this.logger.error(`Failed to create worker: ${e}`,t),new n(a.WORKER_ERROR,`Failed to create worker: ${t instanceof Error?t.message:String(t)}`)}}getWorker(e){return this.workers.get(e)}sendMessage(e,t){const r=this.workers.get(e);if(!r)throw new n(a.WORKER_ERROR,`Worker ${e} not found`);r.postMessage(t),this.logger.debug(`Message sent to worker ${e}:`,t)}terminateWorker(e){const t=this.workers.get(e);t&&(t.terminate(),this.workers.delete(e),this.logger.debug(`Worker terminated: ${e}`))}terminateAll(){this.logger.info(`Terminating all ${this.workers.size} workers`);for(const[e,t]of this.workers)t.terminate(),this.logger.debug(`Worker terminated: ${e}`);this.workers.clear()}getActiveWorkerCount(){return this.workers.size}getWorkerIds(){return Array.from(this.workers.keys())}}class c extends r{constructor(){super(...arguments),this.metrics={noiseReductionLevel:0,processingLatency:0,inputLevel:0,outputLevel:0,timestamp:Date.now(),frameCount:0,droppedFrames:0},this.frameTimestamps=[],this.maxFrameHistory=100}startAutoUpdate(e=100){this.stopAutoUpdate(),this.updateInterval=setInterval(()=>{this.calculateLatency(),this.emit("metrics-update",{...this.metrics})},e)}stopAutoUpdate(){this.updateInterval&&(clearInterval(this.updateInterval),this.updateInterval=void 0)}updateInputLevel(e){this.metrics.inputLevel=Math.max(0,Math.min(1,e))}updateOutputLevel(e){this.metrics.outputLevel=Math.max(0,Math.min(1,e))}updateNoiseReduction(e){this.metrics.noiseReductionLevel=Math.max(0,Math.min(100,e))}recordFrame(e=Date.now()){this.frameTimestamps.push(e),this.frameTimestamps.length>this.maxFrameHistory&&this.frameTimestamps.shift(),this.metrics.frameCount++,this.metrics.timestamp=e}recordDroppedFrame(){this.metrics.droppedFrames++}recordChunk(e){this.emit("chunk-processed",e)}calculateLatency(){if(this.frameTimestamps.length<2)return void(this.metrics.processingLatency=0);const e=[];for(let t=1;t<this.frameTimestamps.length;t++)e.push(this.frameTimestamps[t]-this.frameTimestamps[t-1]);const t=e.reduce((e,t)=>e+t,0)/e.length;this.metrics.processingLatency=t}getMetrics(){return{...this.metrics}}reset(){this.metrics={noiseReductionLevel:0,processingLatency:0,inputLevel:0,outputLevel:0,timestamp:Date.now(),frameCount:0,droppedFrames:0},this.frameTimestamps=[]}calculateRMS(e){let t=0;for(let r=0;r<e.length;r++)t+=e[r]*e[r];return Math.sqrt(t/e.length)}calculatePeak(e){let t=0;for(let r=0;r<e.length;r++)t=Math.max(t,Math.abs(e[r]));return t}}class u extends r{constructor(e,t,r,s){super(),this.currentChunk=[],this.chunkStartTime=Date.now(),this.chunkIndex=0,this.currentSampleCount=0,this.overlapBuffer=[],this.logger=r,this.sampleRate=e,this.metricsManager=s,this.config={chunkDuration:t.chunkDuration,onChunkProcessed:t.onChunkProcessed||void 0,overlap:t.overlap||0},this.samplesPerChunk=Math.floor(this.config.chunkDuration/1e3*this.sampleRate),this.logger.info("ChunkProcessor initialized:",{sampleRate:this.sampleRate,chunkDuration:this.config.chunkDuration,samplesPerChunk:this.samplesPerChunk,overlap:this.config.overlap})}addSamples(e){for(0===this.chunkStartTime&&(this.chunkStartTime=Date.now()),this.currentChunk.push(new Float32Array(e)),this.currentSampleCount+=e.length;this.currentSampleCount>=this.samplesPerChunk;)this.processCurrentChunk()}processCurrentChunk(){const e="chunk-"+this.chunkIndex++,t=Date.now(),r=this.extractChunkSamples(),s=this.applyOverlap(r),i={id:e,data:s,startTime:this.chunkStartTime,endTime:t,sampleRate:this.sampleRate,channelCount:1};this.emit("chunk-ready",i),this.emitChunkMetrics(i,r,s),this.chunkStartTime=t}extractChunkSamples(){const e=new Float32Array(this.samplesPerChunk);let t=0,r=this.samplesPerChunk;for(;r>0&&this.currentChunk.length>0;){const s=this.currentChunk[0],i=Math.min(r,s.length);e.set(s.subarray(0,i),t),t+=i,r-=i,i===s.length?this.currentChunk.shift():this.currentChunk[0]=s.subarray(i)}return this.currentSampleCount-=this.samplesPerChunk,e}applyOverlap(e){if(0===this.config.overlap)return e;const t=Math.floor(this.samplesPerChunk*this.config.overlap),r=new Float32Array(e.length);if(r.set(e),this.overlapBuffer.length>0){const e=this.combineBuffers(this.overlapBuffer),s=Math.min(t,e.length);for(let t=0;t<s;t++){const i=t/s,n=1-i;r[t]=r[t]*i+e[t]*n}}return this.overlapBuffer=[e.subarray(e.length-t)],r}emitChunkMetrics(e,t,r){const s=this.metricsManager.calculateRMS(t),i=this.metricsManager.calculateRMS(r),n=this.metricsManager.calculatePeak(t),a=this.metricsManager.calculatePeak(r),o=s>0?(s-i)/s*100:0,c={originalSize:4*t.length,processedSize:4*r.length,noiseRemoved:Math.max(0,Math.min(100,o)),metrics:{noiseReductionLevel:o,processingLatency:e.endTime-e.startTime,inputLevel:n,outputLevel:a,timestamp:e.endTime,frameCount:Math.floor(r.length/480),droppedFrames:0},duration:this.config.chunkDuration,startTime:e.startTime,endTime:e.endTime};if(this.emit("chunk-processed",c),this.config.onChunkProcessed)try{this.config.onChunkProcessed(c)}catch(e){this.logger.error("Error in chunk processed callback:",e)}this.logger.debug(`Chunk ${e.id} processed:`,{duration:`${c.duration}ms`,noiseRemoved:`${c.noiseRemoved.toFixed(1)}%`,latency:`${c.metrics.processingLatency}ms`})}flush(){if(this.currentSampleCount>0){this.logger.info(`Flushing final chunk with ${this.currentSampleCount} samples`);const e=this.samplesPerChunk-this.currentSampleCount;e>0&&this.addSamples(new Float32Array(e)),this.processCurrentChunk()}this.reset()}reset(){this.currentChunk=[],this.overlapBuffer=[],this.currentSampleCount=0,this.chunkIndex=0,this.chunkStartTime=Date.now(),this.logger.debug("ChunkProcessor reset")}combineBuffers(e){const t=e.reduce((e,t)=>e+t.length,0),r=new Float32Array(t);let s=0;for(const t of e)r.set(t,s),s+=t.length;return r}getStatus(){return{currentSampleCount:this.currentSampleCount,samplesPerChunk:this.samplesPerChunk,chunkIndex:this.chunkIndex,bufferFillPercentage:this.currentSampleCount/this.samplesPerChunk*100}}}class h extends r{constructor(e={}){super(),this.activeStreams=new Map,this.errorHistory=[],this.config={logLevel:e.logLevel||"info",onLog:e.onLog||void 0,noiseReductionLevel:e.noiseReductionLevel||"medium",bufferSize:e.bufferSize||4096,algorithm:e.algorithm||"rnnoise",autoCleanup:e.autoCleanup??!0,cleanupDelay:e.cleanupDelay||3e4,useWorker:e.useWorker??!1,workerPath:e.workerPath||"/murmuraba.worker.js"},this.logger=new i("[Murmuraba]"),this.logger.setLevel(this.config.logLevel),this.config.onLog&&this.logger.setLogHandler(this.config.onLog),this.stateManager=new s,this.workerManager=new o(this.logger),this.metricsManager=new c,this.setupEventForwarding(),this.setupAutoCleanup()}setupEventForwarding(){this.stateManager.on("state-change",(e,t)=>{this.logger.info(`State transition: ${e} -> ${t}`),this.emit("state-change",e,t)}),this.metricsManager.on("metrics-update",e=>{this.emit("metrics-update",e)})}setupAutoCleanup(){if(!this.config.autoCleanup)return;this.on("processing-start",()=>{this.cleanupTimer&&(clearTimeout(this.cleanupTimer),this.cleanupTimer=void 0)}),this.on("processing-end",()=>{this.cleanupTimer&&clearTimeout(this.cleanupTimer),0===this.activeStreams.size&&this.stateManager.isInState("ready")&&(this.cleanupTimer=setTimeout(()=>{this.logger.info("Auto-cleanup triggered due to inactivity"),this.destroy()},this.config.cleanupDelay))})}async initialize(){if(this.initPromise)return this.initPromise;if(!this.stateManager.canTransitionTo("initializing"))throw new n(a.ALREADY_INITIALIZED,"Engine is already initialized or in an invalid state");return this.initPromise=this.performInitialization(),this.initPromise}async performInitialization(){this.stateManager.transitionTo("initializing");try{this.logger.info("Initializing Murmuraba engine..."),this.audioContext=new AudioContext({sampleRate:48e3}),await this.loadWasmModule(),this.metricsManager.startAutoUpdate(100),this.stateManager.transitionTo("ready"),this.emit("initialized"),this.logger.info("Murmuraba engine initialized successfully")}catch(e){this.stateManager.transitionTo("error");const t=new n(a.INITIALIZATION_FAILED,`Initialization failed: ${e instanceof Error?e.message:String(e)}`,e);throw this.emit("error",t),t}}async loadWasmModule(){this.logger.debug("Loading WASM module...");const e=document.createElement("script");e.src="/rnnoise-fixed.js",await new Promise((t,r)=>{e.onload=()=>t(),e.onerror=()=>r(new Error("Failed to load RNNoise script")),document.head.appendChild(e)});const t=window.createRNNWasmModule;if(!t)throw new Error("RNNoise WASM module creator not found");if(this.wasmModule=await t({locateFile:e=>e.endsWith(".wasm")?`/dist/${e}`:e}),this.rnnoiseState=this.wasmModule._rnnoise_create(0),!this.rnnoiseState)throw new Error("Failed to create RNNoise state");this.inputPtr=this.wasmModule._malloc(1920),this.outputPtr=this.wasmModule._malloc(1920),await this.warmupModel(),this.logger.debug("WASM module loaded successfully")}async warmupModel(){this.logger.debug("Warming up noise reduction model...");const e=new Float32Array(480);for(let t=0;t<10;t++)this.processFrame(e)}processFrame(e){if(!(this.wasmModule&&this.rnnoiseState&&this.inputPtr&&this.outputPtr))throw new Error("WASM module not initialized");this.wasmModule.HEAPF32.set(e,this.inputPtr>>2),this.wasmModule._rnnoise_process_frame(this.rnnoiseState,this.outputPtr,this.inputPtr);const t=new Float32Array(480);for(let e=0;e<480;e++)t[e]=this.wasmModule.HEAPF32[(this.outputPtr>>2)+e];return t}async processStream(e,t){this.stateManager.requireState("ready","processing");const r=this.generateStreamId();this.logger.info(`Processing stream ${r}`);try{const s=await this.createStreamController(e,r,t);return this.activeStreams.set(r,s),1===this.activeStreams.size&&(this.stateManager.transitionTo("processing"),this.emit("processing-start")),s}catch(e){const t=new n(a.PROCESSING_FAILED,`Failed to process stream: ${e instanceof Error?e.message:String(e)}`,e);throw this.emit("error",t),t}}async createStreamController(e,t,r){if(!this.audioContext)throw new Error("Audio context not initialized");const s=this.audioContext.createMediaStreamSource(e),i=this.audioContext.createMediaStreamDestination(),n=this.audioContext.createScriptProcessor(this.config.bufferSize,1,1),a=this.audioContext.createBiquadFilter();a.type="notch",a.frequency.value=1e3,a.Q.value=30;const o=this.audioContext.createBiquadFilter();o.type="notch",o.frequency.value=2e3,o.Q.value=30;const c=this.audioContext.createBiquadFilter();c.type="highpass",c.frequency.value=80,c.Q.value=.7;const h=this.audioContext.createBiquadFilter();h.type="lowshelf",h.frequency.value=200,h.gain.value=-3;let l=!1,g=!1;const d=[],m=[];let p;r&&(p=new u(this.audioContext.sampleRate,r,this.logger,this.metricsManager),p.on("chunk-processed",e=>{this.logger.debug("Chunk processed:",e),this.metricsManager.recordChunk(e)})),n.onaudioprocess=e=>{if(g||l)return void e.outputBuffer.getChannelData(0).fill(0);const t=e.inputBuffer.getChannelData(0),r=e.outputBuffer.getChannelData(0);this.metricsManager.calculateRMS(t);const s=this.metricsManager.calculatePeak(t);this.metricsManager.updateInputLevel(s);for(let e=0;e<t.length;e++)d.push(t[e]);!p||l||g||p.addSamples(t);let i=0,n=0,a=0;for(;d.length>=480;){const e=new Float32Array(d.splice(0,480)),t=this.metricsManager.calculateRMS(e),r=this.processFrame(e),s=this.metricsManager.calculateRMS(r),o=this.getReductionFactor();for(let e=0;e<r.length;e++)r[e]*=o,m.push(r[e]);i+=t,n+=s*o,a++,this.metricsManager.recordFrame()}for(let e=0;e<r.length;e++)m.length>0?r[e]=m.shift():r[e]=0;this.metricsManager.calculateRMS(r);const o=this.metricsManager.calculatePeak(r);if(this.metricsManager.updateOutputLevel(o),a>0){const e=i/a,t=n/a,r=e>0?Math.max(0,100*(1-t/e)):0;this.metricsManager.updateNoiseReduction(r)}},s.connect(c),c.connect(a),a.connect(o),o.connect(h),h.connect(n),n.connect(i);const f={stream:i.stream,processor:{id:t,state:"processing",inputNode:s,outputNode:i},stop:()=>{g=!0,p&&p.flush(),n.disconnect(),s.disconnect(),this.activeStreams.delete(t),this.logger.info(`Stream ${t} stopped`),0===this.activeStreams.size&&(this.stateManager.transitionTo("ready"),this.emit("processing-end"))},pause:()=>{l=!0,f.processor.state="paused",this.logger.debug(`Stream ${t} paused`)},resume:()=>{l=!1,f.processor.state="processing",this.logger.debug(`Stream ${t} resumed`)},getState:()=>f.processor.state};return f}getReductionFactor(){switch(this.config.noiseReductionLevel){case"low":return.9;case"medium":case"auto":default:return.7;case"high":return.5}}generateStreamId(){return`stream-${Date.now()}-${Math.random().toString(36).substr(2,9)}`}async destroy(e=!1){if(!this.stateManager.canTransitionTo("destroying")){if(!e)throw new n(a.CLEANUP_FAILED,"Cannot destroy engine in current state");this.logger.warn("Force destroying engine")}this.stateManager.transitionTo("destroying"),this.logger.info("Destroying Murmuraba engine...");try{for(const[e,t]of this.activeStreams)t.stop();this.activeStreams.clear(),this.metricsManager.stopAutoUpdate(),this.workerManager.terminateAll(),this.wasmModule&&(this.inputPtr&&this.wasmModule._free(this.inputPtr),this.outputPtr&&this.wasmModule._free(this.outputPtr),this.rnnoiseState&&this.wasmModule._rnnoise_destroy(this.rnnoiseState)),this.audioContext&&"closed"!==this.audioContext.state&&await this.audioContext.close(),this.cleanupTimer&&clearTimeout(this.cleanupTimer),this.removeAllListeners(),this.stateManager.transitionTo("destroyed"),this.emit("destroyed"),this.logger.info("Murmuraba engine destroyed successfully")}catch(e){this.stateManager.transitionTo("error");const t=new n(a.CLEANUP_FAILED,`Cleanup failed: ${e instanceof Error?e.message:String(e)}`,e);throw this.emit("error",t),t}}getMetrics(){return this.metricsManager.getMetrics()}onMetricsUpdate(e){this.on("metrics-update",e)}getDiagnostics(){return{engineVersion:"2.0.0",wasmLoaded:!!this.wasmModule,activeProcessors:this.activeStreams.size,memoryUsage:performance.memory?.usedJSHeapSize||0,processingTime:this.metricsManager.getMetrics().processingLatency,engineState:this.stateManager.getState(),errors:this.errorHistory}}recordError(e){this.errorHistory.push({timestamp:Date.now(),error:e}),this.errorHistory.length>100&&this.errorHistory.shift()}}let l=null;async function g(e){if(l)throw new Error("Audio engine is already initialized. Call destroyEngine() first.");l=new h(e),await l.initialize()}function d(){if(!l)throw new Error("Audio engine not initialized. Call initializeAudioEngine() first.");return l}async function m(e){return d().processStream(e)}async function p(e,t){return d().processStream(e,t)}async function f(e){l&&(await l.destroy(e?.force||!1),l=null)}function w(){return l?l.getDiagnostics().engineState:"uninitialized"}function S(){return d().getDiagnostics()}function M(e){d().onMetricsUpdate(e)}const y="1.2.1",k=y;e.ErrorCodes=a,e.EventEmitter=r,e.Logger=i,e.MURMURABA_VERSION=k,e.MetricsManager=c,e.MurmubaraEngine=h,e.MurmubaraError=n,e.StateManager=s,e.VERSION=y,e.WorkerManager=o,e.destroyEngine=f,e.getDiagnostics=S,e.getEngine=d,e.getEngineStatus=w,e.initializeAudioEngine=g,e.onMetricsUpdate=M,e.processStream=m,e.processStreamChunked=p,e.useMurmubaraEngine=function(e={}){const{autoInitialize:r=!1,...s}=e,[i,n]=t.useState(!1),[a,o]=t.useState(!1),[c,u]=t.useState(null),[h,l]=t.useState("uninitialized"),[d,y]=t.useState(null),[k,C]=t.useState(null);t.useRef(null);const v=t.useRef(null),E=t.useCallback(async()=>v.current?v.current:i?void 0:(o(!0),u(null),v.current=(async()=>{try{await g(s),M(e=>{y(e)}),n(!0),l("ready"),T()}catch(e){const t=e instanceof Error?e.message:String(e);throw u(t),l("error"),e}finally{o(!1),v.current=null}})(),v.current),[s,i]),I=t.useCallback(async(e=!1)=>{if(i)try{await f({force:e}),n(!1),l("destroyed"),y(null),C(null)}catch(e){const t=e instanceof Error?e.message:String(e);throw u(t),e}},[i]),L=t.useCallback(async e=>{if(!i)throw new Error("Engine not initialized");try{const t=await m(e);return T(),t}catch(e){const t=e instanceof Error?e.message:String(e);throw u(t),e}},[i]),A=t.useCallback(async(e,t)=>{if(!i)throw new Error("Engine not initialized");try{const r=await p(e,t);return T(),r}catch(e){const t=e instanceof Error?e.message:String(e);throw u(t),e}},[i]),T=t.useCallback(()=>{if(!i)return C(null),null;try{const e=S();return C(e),l(e.engineState),e}catch{return null}},[i]),R=t.useCallback(()=>{u(null)},[]);return t.useEffect(()=>{!r||i||a||E()},[r,i,a,E]),t.useEffect(()=>{if(!i)return;const e=setInterval(()=>{try{const e=w();l(e)}catch{}},1e3);return()=>clearInterval(e)},[i]),t.useEffect(()=>()=>{i&&I(!0).catch(console.error)},[]),{isInitialized:i,isLoading:a,error:c,engineState:h,metrics:d,diagnostics:k,initialize:E,destroy:I,processStream:L,processStreamChunked:A,getDiagnostics:T,resetError:R}}});
//# sourceMappingURL=index.umd.min.js.map
