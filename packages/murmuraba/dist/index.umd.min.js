!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("react")):"function"==typeof define&&define.amd?define(["exports","react"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).Murmuraba={},e.React)}(this,function(e,t){"use strict";class r{constructor(){this.events=new Map}on(e,t){this.events.has(e)||this.events.set(e,new Set),this.events.get(e).add(t)}off(e,t){const r=this.events.get(e);r&&(r.delete(t),0===r.size&&this.events.delete(e))}emit(e,...t){const r=this.events.get(e);r&&r.forEach(r=>{try{r(...t)}catch(t){console.error(`Error in event handler for ${String(e)}:`,t)}})}once(e,t){const r=(...i)=>{this.off(e,r),t(...i)};this.on(e,r)}removeAllListeners(e){e?this.events.delete(e):this.events.clear()}listenerCount(e){const t=this.events.get(e);return t?t.size:0}}class i extends r{constructor(){super(...arguments),this.currentState="uninitialized",this.allowedTransitions=new Map([["uninitialized",["initializing","error"]],["initializing",["ready","error"]],["ready",["processing","destroying","error"]],["processing",["ready","paused","destroying","error"]],["paused",["processing","ready","destroying","error"]],["destroying",["destroyed","error"]],["destroyed",[]],["error",["initializing","destroying"]]])}getState(){return this.currentState}canTransitionTo(e){return(this.allowedTransitions.get(this.currentState)||[]).includes(e)}transitionTo(e){if(!this.canTransitionTo(e))return console.warn(`Invalid state transition: ${this.currentState} -> ${e}`),!1;const t=this.currentState;return this.currentState=e,this.emit("state-change",t,e),!0}isInState(...e){return e.includes(this.currentState)}requireState(...e){if(!this.isInState(...e))throw new Error(`Operation requires state to be one of: ${e.join(", ")}, but current state is: ${this.currentState}`)}reset(){const e=this.currentState;this.currentState="uninitialized","uninitialized"!==e&&this.emit("state-change",e,"uninitialized")}}class s{constructor(e="[Murmuraba]"){this.level="info",this.prefix=e}setLevel(e){this.level=e}setLogHandler(e){this.onLog=e}shouldLog(e){const t=["none","error","warn","info","debug"],r=t.indexOf(this.level),i=t.indexOf(e);return r>0&&i<=r}log(e,t,r){if(!this.shouldLog(e))return;const i=(new Date).toISOString(),s=`${this.prefix} [${i}] [${e.toUpperCase()}] ${t}`;if(this.onLog)this.onLog(e,s,r);else{const t="error"===e?console.error:"warn"===e?console.warn:console.log;void 0!==r?t(s,r):t(s)}}error(e,t){this.log("error",e,t)}warn(e,t){this.log("warn",e,t)}info(e,t){this.log("info",e,t)}debug(e,t){this.log("debug",e,t)}}class n extends Error{constructor(e,t,r){super(t),this.name="MurmubaraError",this.code=e,this.details=r}}const a={WASM_NOT_LOADED:"WASM_NOT_LOADED",INVALID_STREAM:"INVALID_STREAM",ENGINE_BUSY:"ENGINE_BUSY",INITIALIZATION_FAILED:"INITIALIZATION_FAILED",PROCESSING_FAILED:"PROCESSING_FAILED",CLEANUP_FAILED:"CLEANUP_FAILED",WORKER_ERROR:"WORKER_ERROR",INVALID_CONFIG:"INVALID_CONFIG",NOT_INITIALIZED:"NOT_INITIALIZED",ALREADY_INITIALIZED:"ALREADY_INITIALIZED"};class o{constructor(e){this.workers=new Map,this.logger=e}createWorker(e,t){if(this.workers.has(e))throw new n(a.WORKER_ERROR,`Worker with id ${e} already exists`);try{const r=new Worker(t);return this.workers.set(e,r),this.logger.debug(`Worker created: ${e}`),r}catch(t){throw this.logger.error(`Failed to create worker: ${e}`,t),new n(a.WORKER_ERROR,`Failed to create worker: ${t instanceof Error?t.message:String(t)}`)}}getWorker(e){return this.workers.get(e)}sendMessage(e,t){const r=this.workers.get(e);if(!r)throw new n(a.WORKER_ERROR,`Worker ${e} not found`);r.postMessage(t),this.logger.debug(`Message sent to worker ${e}:`,t)}terminateWorker(e){const t=this.workers.get(e);t&&(t.terminate(),this.workers.delete(e),this.logger.debug(`Worker terminated: ${e}`))}terminateAll(){this.logger.info(`Terminating all ${this.workers.size} workers`);for(const[e,t]of this.workers)t.terminate(),this.logger.debug(`Worker terminated: ${e}`);this.workers.clear()}getActiveWorkerCount(){return this.workers.size}getWorkerIds(){return Array.from(this.workers.keys())}}class u extends r{constructor(){super(...arguments),this.metrics={noiseReductionLevel:0,processingLatency:0,inputLevel:0,outputLevel:0,timestamp:Date.now(),frameCount:0,droppedFrames:0},this.frameTimestamps=[],this.maxFrameHistory=100}startAutoUpdate(e=100){this.stopAutoUpdate(),this.updateInterval=setInterval(()=>{this.calculateLatency(),this.emit("metrics-update",{...this.metrics})},e)}stopAutoUpdate(){this.updateInterval&&(clearInterval(this.updateInterval),this.updateInterval=void 0)}updateInputLevel(e){this.metrics.inputLevel=Math.max(0,Math.min(1,e))}updateOutputLevel(e){this.metrics.outputLevel=Math.max(0,Math.min(1,e))}updateNoiseReduction(e){this.metrics.noiseReductionLevel=Math.max(0,Math.min(100,e))}recordFrame(e=Date.now()){this.frameTimestamps.push(e),this.frameTimestamps.length>this.maxFrameHistory&&this.frameTimestamps.shift(),this.metrics.frameCount++,this.metrics.timestamp=e}recordDroppedFrame(){this.metrics.droppedFrames++}recordChunk(e){this.emit("chunk-processed",e)}calculateLatency(){if(this.frameTimestamps.length<2)return void(this.metrics.processingLatency=0);const e=[];for(let t=1;t<this.frameTimestamps.length;t++)e.push(this.frameTimestamps[t]-this.frameTimestamps[t-1]);const t=e.reduce((e,t)=>e+t,0)/e.length;this.metrics.processingLatency=t}getMetrics(){return{...this.metrics}}reset(){this.metrics={noiseReductionLevel:0,processingLatency:0,inputLevel:0,outputLevel:0,timestamp:Date.now(),frameCount:0,droppedFrames:0},this.frameTimestamps=[]}calculateRMS(e){let t=0;for(let r=0;r<e.length;r++)t+=e[r]*e[r];return Math.sqrt(t/e.length)}calculatePeak(e){let t=0;for(let r=0;r<e.length;r++)t=Math.max(t,Math.abs(e[r]));return t}}class c extends r{constructor(e,t,r,i){super(),this.currentChunk=[],this.chunkStartTime=Date.now(),this.chunkIndex=0,this.currentSampleCount=0,this.overlapBuffer=[],this.logger=r,this.sampleRate=e,this.metricsManager=i,this.config={chunkDuration:t.chunkDuration,onChunkProcessed:t.onChunkProcessed||void 0,overlap:t.overlap||0},this.samplesPerChunk=Math.floor(this.config.chunkDuration/1e3*this.sampleRate),this.logger.info("ChunkProcessor initialized:",{sampleRate:this.sampleRate,chunkDuration:this.config.chunkDuration,samplesPerChunk:this.samplesPerChunk,overlap:this.config.overlap})}addSamples(e){for(0===this.chunkStartTime&&(this.chunkStartTime=Date.now()),this.currentChunk.push(new Float32Array(e)),this.currentSampleCount+=e.length;this.currentSampleCount>=this.samplesPerChunk;)this.processCurrentChunk()}processCurrentChunk(){const e="chunk-"+this.chunkIndex++,t=Date.now(),r=this.extractChunkSamples(),i=this.applyOverlap(r),s={id:e,data:i,startTime:this.chunkStartTime,endTime:t,sampleRate:this.sampleRate,channelCount:1};this.emit("chunk-ready",s),this.emitChunkMetrics(s,r,i),this.chunkStartTime=t}extractChunkSamples(){const e=new Float32Array(this.samplesPerChunk);let t=0,r=this.samplesPerChunk;for(;r>0&&this.currentChunk.length>0;){const i=this.currentChunk[0],s=Math.min(r,i.length);e.set(i.subarray(0,s),t),t+=s,r-=s,s===i.length?this.currentChunk.shift():this.currentChunk[0]=i.subarray(s)}return this.currentSampleCount-=this.samplesPerChunk,e}applyOverlap(e){if(0===this.config.overlap)return e;const t=Math.floor(this.samplesPerChunk*this.config.overlap),r=new Float32Array(e.length);if(r.set(e),this.overlapBuffer.length>0){const e=this.combineBuffers(this.overlapBuffer),i=Math.min(t,e.length);for(let t=0;t<i;t++){const s=t/i,n=1-s;r[t]=r[t]*s+e[t]*n}}return this.overlapBuffer=[e.subarray(e.length-t)],r}emitChunkMetrics(e,t,r){const i=this.metricsManager.calculateRMS(t),s=this.metricsManager.calculateRMS(r),n=this.metricsManager.calculatePeak(t),a=this.metricsManager.calculatePeak(r),o=i>0?(i-s)/i*100:0,u={originalSize:4*t.length,processedSize:4*r.length,noiseRemoved:Math.max(0,Math.min(100,o)),metrics:{noiseReductionLevel:o,processingLatency:e.endTime-e.startTime,inputLevel:n,outputLevel:a,timestamp:e.endTime,frameCount:Math.floor(r.length/480),droppedFrames:0},duration:this.config.chunkDuration,startTime:e.startTime,endTime:e.endTime};if(this.emit("chunk-processed",u),this.config.onChunkProcessed)try{this.config.onChunkProcessed(u)}catch(e){this.logger.error("Error in chunk processed callback:",e)}this.logger.debug(`Chunk ${e.id} processed:`,{duration:`${u.duration}ms`,noiseRemoved:`${u.noiseRemoved.toFixed(1)}%`,latency:`${u.metrics.processingLatency}ms`})}flush(){if(this.currentSampleCount>0){this.logger.info(`Flushing final chunk with ${this.currentSampleCount} samples`);const e=this.samplesPerChunk-this.currentSampleCount;e>0&&this.addSamples(new Float32Array(e)),this.processCurrentChunk()}this.reset()}reset(){this.currentChunk=[],this.overlapBuffer=[],this.currentSampleCount=0,this.chunkIndex=0,this.chunkStartTime=Date.now(),this.logger.debug("ChunkProcessor reset")}combineBuffers(e){const t=e.reduce((e,t)=>e+t.length,0),r=new Float32Array(t);let i=0;for(const t of e)r.set(t,i),i+=t.length;return r}getStatus(){return{currentSampleCount:this.currentSampleCount,samplesPerChunk:this.samplesPerChunk,chunkIndex:this.chunkIndex,bufferFillPercentage:this.currentSampleCount/this.samplesPerChunk*100}}}class l extends r{constructor(e={}){super(),this.activeStreams=new Map,this.errorHistory=[],this.config={logLevel:e.logLevel||"info",onLog:e.onLog||void 0,noiseReductionLevel:e.noiseReductionLevel||"medium",bufferSize:e.bufferSize||4096,algorithm:e.algorithm||"rnnoise",autoCleanup:e.autoCleanup??!0,cleanupDelay:e.cleanupDelay||3e4,useWorker:e.useWorker??!1,workerPath:e.workerPath||"/murmuraba.worker.js",allowDegraded:e.allowDegraded??!1},this.logger=new s("[Murmuraba]"),this.logger.setLevel(this.config.logLevel),this.config.onLog&&this.logger.setLogHandler(this.config.onLog),this.stateManager=new i,this.workerManager=new o(this.logger),this.metricsManager=new u,this.setupEventForwarding(),this.setupAutoCleanup()}setupEventForwarding(){this.stateManager.on("state-change",(e,t)=>{this.logger.info(`State transition: ${e} -> ${t}`),this.emit("state-change",e,t)}),this.metricsManager.on("metrics-update",e=>{this.emit("metrics-update",e)})}setupAutoCleanup(){if(!this.config.autoCleanup)return;this.on("processing-start",()=>{this.cleanupTimer&&(clearTimeout(this.cleanupTimer),this.cleanupTimer=void 0)}),this.on("processing-end",()=>{this.cleanupTimer&&clearTimeout(this.cleanupTimer),0===this.activeStreams.size&&this.stateManager.isInState("ready")&&(this.cleanupTimer=setTimeout(()=>{this.logger.info("Auto-cleanup triggered due to inactivity"),this.destroy()},this.config.cleanupDelay))})}async initialize(){if(this.initPromise)return this.initPromise;if(!this.stateManager.canTransitionTo("initializing"))throw new n(a.ALREADY_INITIALIZED,"Engine is already initialized or in an invalid state");return this.initPromise=this.performInitialization(),this.initPromise}async performInitialization(){this.stateManager.transitionTo("initializing");try{if(this.logger.info("Initializing Murmuraba engine..."),!this.checkEnvironmentSupport())throw new Error("Environment not supported: Missing required APIs");this.stateManager.transitionTo("creating-context"),await this.initializeAudioContext(),this.stateManager.transitionTo("loading-wasm"),await this.loadWasmModuleWithTimeout(5e3),this.metricsManager.startAutoUpdate(100),this.stateManager.transitionTo("ready"),this.emit("initialized"),this.logger.info("Murmuraba engine initialized successfully")}catch(e){this.stateManager.transitionTo("error"),this.recordError(e);const t=new n(a.INITIALIZATION_FAILED,`Initialization failed: ${e instanceof Error?e.message:String(e)}`,e);if(this.emit("error",t),!this.config.allowDegraded)throw t;this.logger.warn("Attempting degraded mode initialization..."),await this.initializeDegraded()}}checkEnvironmentSupport(){const e=!(!window.AudioContext&&!window.webkitAudioContext),t=!!window.WebAssembly;return e||this.logger.error("AudioContext API not supported"),t||this.logger.error("WebAssembly not supported"),e&&t}async initializeAudioContext(){try{const e=window.AudioContext||window.webkitAudioContext;this.audioContext=new e({sampleRate:48e3}),"suspended"===this.audioContext.state&&await this.audioContext.resume()}catch(e){throw new Error(`Failed to create AudioContext: ${e instanceof Error?e.message:String(e)}`)}}async loadWasmModuleWithTimeout(e){const t=new Promise((t,r)=>{setTimeout(()=>r(new Error(`WASM loading timeout after ${e}ms`)),e)});try{await Promise.race([this.loadWasmModule(),t])}catch(e){throw e instanceof Error&&e.message.includes("timeout")&&this.logger.error("WASM module loading timed out"),e}}recordError(e){const t=e instanceof Error?e.message:String(e);this.errorHistory.push({timestamp:Date.now(),error:t}),this.errorHistory.length>10&&this.errorHistory.shift()}async initializeDegraded(){if(this.logger.info("Initializing in degraded mode..."),this.stateManager.transitionTo("degraded"),!this.audioContext)try{await this.initializeAudioContext()}catch{return void this.logger.error("Failed to create audio context even in degraded mode")}this.emit("degraded-mode"),this.logger.warn("Engine running in degraded mode - noise reduction disabled")}async loadWasmModule(){this.logger.debug("Loading WASM module...");const e=document.createElement("script");e.src="/rnnoise-fixed.js",await new Promise((t,r)=>{e.onload=()=>t(),e.onerror=()=>r(new Error("Failed to load RNNoise script")),document.head.appendChild(e)});const t=window.createRNNWasmModule;if(!t)throw new Error("RNNoise WASM module creator not found");if(this.wasmModule=await t({locateFile:e=>e.endsWith(".wasm")?`/dist/${e}`:e}),this.rnnoiseState=this.wasmModule._rnnoise_create(0),!this.rnnoiseState)throw new Error("Failed to create RNNoise state");this.inputPtr=this.wasmModule._malloc(1920),this.outputPtr=this.wasmModule._malloc(1920),await this.warmupModel(),this.logger.debug("WASM module loaded successfully")}async warmupModel(){this.logger.debug("Warming up noise reduction model...");const e=new Float32Array(480);for(let t=0;t<10;t++)this.processFrame(e)}processFrame(e){if(!(this.wasmModule&&this.rnnoiseState&&this.inputPtr&&this.outputPtr))throw new Error("WASM module not initialized");this.wasmModule.HEAPF32.set(e,this.inputPtr>>2),this.wasmModule._rnnoise_process_frame(this.rnnoiseState,this.outputPtr,this.inputPtr);const t=new Float32Array(480);for(let e=0;e<480;e++)t[e]=this.wasmModule.HEAPF32[(this.outputPtr>>2)+e];return t}async processStream(e,t){this.stateManager.requireState("ready","processing");const r=this.generateStreamId();this.logger.info(`Processing stream ${r}`);try{const i=await this.createStreamController(e,r,t);return this.activeStreams.set(r,i),1===this.activeStreams.size&&(this.stateManager.transitionTo("processing"),this.emit("processing-start")),i}catch(e){const t=new n(a.PROCESSING_FAILED,`Failed to process stream: ${e instanceof Error?e.message:String(e)}`,e);throw this.emit("error",t),t}}async createStreamController(e,t,r){if(!this.audioContext)throw new Error("Audio context not initialized");const i=this.audioContext.createMediaStreamSource(e),s=this.audioContext.createMediaStreamDestination(),n=this.audioContext.createScriptProcessor(this.config.bufferSize,1,1),a=this.audioContext.createBiquadFilter();a.type="notch",a.frequency.value=1e3,a.Q.value=30;const o=this.audioContext.createBiquadFilter();o.type="notch",o.frequency.value=2e3,o.Q.value=30;const u=this.audioContext.createBiquadFilter();u.type="highpass",u.frequency.value=80,u.Q.value=.7;const l=this.audioContext.createBiquadFilter();l.type="lowshelf",l.frequency.value=200,l.gain.value=-3;let h=!1,d=!1;const m=[],g=[];let p;r&&(p=new c(this.audioContext.sampleRate,r,this.logger,this.metricsManager),p.on("chunk-processed",e=>{this.logger.debug("Chunk processed:",e),this.metricsManager.recordChunk(e)})),n.onaudioprocess=e=>{if(d||h)return void e.outputBuffer.getChannelData(0).fill(0);const t=e.inputBuffer.getChannelData(0),r=e.outputBuffer.getChannelData(0);this.metricsManager.calculateRMS(t);const i=this.metricsManager.calculatePeak(t);this.metricsManager.updateInputLevel(i);for(let e=0;e<t.length;e++)m.push(t[e]);!p||h||d||p.addSamples(t);let s=0,n=0,a=0;for(;m.length>=480;){const e=new Float32Array(m.splice(0,480)),t=this.metricsManager.calculateRMS(e),r=this.processFrame(e),i=this.metricsManager.calculateRMS(r),o=this.getReductionFactor();for(let e=0;e<r.length;e++)r[e]*=o,g.push(r[e]);s+=t,n+=i*o,a++,this.metricsManager.recordFrame()}for(let e=0;e<r.length;e++)g.length>0?r[e]=g.shift():r[e]=0;this.metricsManager.calculateRMS(r);const o=this.metricsManager.calculatePeak(r);if(this.metricsManager.updateOutputLevel(o),a>0){const e=s/a,t=n/a,r=e>0?Math.max(0,100*(1-t/e)):0;this.metricsManager.updateNoiseReduction(r)}},i.connect(u),u.connect(a),a.connect(o),o.connect(l),l.connect(n),n.connect(s);const f={stream:s.stream,processor:{id:t,state:"processing",inputNode:i,outputNode:s},stop:()=>{d=!0,p&&p.flush(),n.disconnect(),i.disconnect(),this.activeStreams.delete(t),this.logger.info(`Stream ${t} stopped`),0===this.activeStreams.size&&(this.stateManager.transitionTo("ready"),this.emit("processing-end"))},pause:()=>{h=!0,f.processor.state="paused",this.logger.debug(`Stream ${t} paused`)},resume:()=>{h=!1,f.processor.state="processing",this.logger.debug(`Stream ${t} resumed`)},getState:()=>f.processor.state};return f}getReductionFactor(){switch(this.config.noiseReductionLevel){case"low":return.9;case"medium":case"auto":default:return.7;case"high":return.5}}generateStreamId(){return`stream-${Date.now()}-${Math.random().toString(36).substr(2,9)}`}async destroy(e=!1){if(!this.stateManager.canTransitionTo("destroying")){if(!e)throw new n(a.CLEANUP_FAILED,"Cannot destroy engine in current state");this.logger.warn("Force destroying engine")}this.stateManager.transitionTo("destroying"),this.logger.info("Destroying Murmuraba engine...");try{for(const[e,t]of this.activeStreams)t.stop();this.activeStreams.clear(),this.metricsManager.stopAutoUpdate(),this.workerManager.terminateAll(),this.wasmModule&&(this.inputPtr&&this.wasmModule._free(this.inputPtr),this.outputPtr&&this.wasmModule._free(this.outputPtr),this.rnnoiseState&&this.wasmModule._rnnoise_destroy(this.rnnoiseState)),this.audioContext&&"closed"!==this.audioContext.state&&await this.audioContext.close(),this.cleanupTimer&&clearTimeout(this.cleanupTimer),this.removeAllListeners(),this.stateManager.transitionTo("destroyed"),this.emit("destroyed"),this.logger.info("Murmuraba engine destroyed successfully")}catch(e){this.stateManager.transitionTo("error");const t=new n(a.CLEANUP_FAILED,`Cleanup failed: ${e instanceof Error?e.message:String(e)}`,e);throw this.emit("error",t),t}}getMetrics(){return this.metricsManager.getMetrics()}onMetricsUpdate(e){this.on("metrics-update",e)}getDiagnostics(){const e=window.React?.version||"unknown",t={hasWASM:!!window.WebAssembly,hasAudioContext:!(!window.AudioContext&&!window.webkitAudioContext),hasWorklet:!!window.AudioWorkletNode,maxChannels:this.audioContext?.destination.maxChannelCount||0};return{version:"1.3.0",engineVersion:"2.0.0",reactVersion:e,browserInfo:{name:this.getBrowserName(),version:this.getBrowserVersion(),audioAPIsSupported:this.getAudioAPIsSupported()},wasmLoaded:!!this.wasmModule,activeProcessors:this.activeStreams.size,memoryUsage:performance.memory?.usedJSHeapSize||0,processingTime:this.metricsManager.getMetrics().processingLatency,engineState:this.stateManager.getState(),capabilities:t,errors:this.errorHistory,initializationLog:[],performanceMetrics:{wasmLoadTime:0,contextCreationTime:0,totalInitTime:0}}}getBrowserName(){const e=navigator.userAgent;return e.includes("Chrome")?"Chrome":e.includes("Firefox")?"Firefox":e.includes("Safari")?"Safari":e.includes("Edge")?"Edge":"Unknown"}getBrowserVersion(){const e=navigator.userAgent.match(/(Chrome|Firefox|Safari|Edge)\/([\d.]+)/);return e?e[2]:"unknown"}getAudioAPIsSupported(){const e=[];return(window.AudioContext||window.webkitAudioContext)&&e.push("AudioContext"),window.AudioWorkletNode&&e.push("AudioWorklet"),window.webkitAudioContext&&e.push("webkitAudioContext"),window.MediaStream&&e.push("MediaStream"),window.MediaRecorder&&e.push("MediaRecorder"),e}async runDiagnosticTests(){const e={timestamp:Date.now(),tests:[],passed:0,failed:0,warnings:0},t={name:"Environment Support",passed:!1,message:"",duration:0},r=Date.now();this.checkEnvironmentSupport()?(t.passed=!0,t.message="All required APIs are supported"):t.message="Missing required APIs",t.duration=Date.now()-r,e.tests.push(t);const i={name:"Audio Context Creation",passed:!1,message:"",duration:0},s=Date.now();try{this.audioContext||await this.initializeAudioContext(),i.passed=!0,i.message=`Audio context created (state: ${this.audioContext?.state})`}catch(e){i.message=`Failed: ${e instanceof Error?e.message:String(e)}`}i.duration=Date.now()-s,e.tests.push(i);const n={name:"WASM Module Loading",passed:!1,message:"",duration:0},a=Date.now();this.wasmModule?(n.passed=!0,n.message="WASM module already loaded"):n.message="WASM module not loaded (run initialize first)",n.duration=Date.now()-a,e.tests.push(n);const o={name:"Frame Processing",passed:!1,message:"",duration:0},u=Date.now();try{if(this.wasmModule&&this.rnnoiseState){const e=new Float32Array(480),t=this.processFrame(e);o.passed=480===t.length,o.message=o.passed?"Frame processing successful":"Invalid output size"}else o.message="Engine not initialized"}catch(e){o.message=`Failed: ${e instanceof Error?e.message:String(e)}`}return o.duration=Date.now()-u,e.tests.push(o),e.passed=e.tests.filter(e=>e.passed).length,e.failed=e.tests.filter(e=>!e.passed).length,e}}let h=null;async function d(e){if(h)throw new Error("Audio engine is already initialized. Call destroyEngine() first.");h=new l(e),await h.initialize()}function m(){if(!h)throw new Error("Audio engine not initialized. Call initializeAudioEngine() first.");return h}async function g(e){return m().processStream(e)}async function p(e,t){return m().processStream(e,t)}async function f(e){h&&(await h.destroy(e?.force||!1),h=null)}function w(){return h?h.getDiagnostics().engineState:"uninitialized"}function S(){return m().getDiagnostics()}function y(e){m().onMetricsUpdate(e)}function M(e={}){const{autoInitialize:r=!1,fallbackToManual:i=!1,onInitError:s,react19Mode:n=!1,...a}=e,o=t.version.startsWith("19")||n,[u,c]=t.useState(!1),[l,h]=t.useState(!1),[m,M]=t.useState(null),[E,C]=t.useState("uninitialized"),[k,A]=t.useState(null),[I,v]=t.useState(null);t.useRef(null);const F=t.useRef(null),T=t.useCallback(async()=>F.current?F.current:u?void 0:(h(!0),M(null),F.current=(async()=>{try{await d(a),y(e=>{A(e)}),c(!0),C("ready"),P()}catch(e){const t=e instanceof Error?e:new Error(String(e)),r=t.message;if(M(r),C("error"),s&&s(t),!i||!o)throw e;console.warn("[MurmubaraEngine] Auto-init failed in React 19, attempting manual fallback")}finally{h(!1),F.current=null}})(),F.current),[a,u]),R=t.useCallback(async(e=!1)=>{if(u)try{await f({force:e}),c(!1),C("destroyed"),A(null),v(null)}catch(e){const t=e instanceof Error?e.message:String(e);throw M(t),e}},[u]),x=t.useCallback(async e=>{if(!u)throw new Error("Engine not initialized");try{const t=await g(e);return P(),t}catch(e){const t=e instanceof Error?e.message:String(e);throw M(t),e}},[u]),L=t.useCallback(async(e,t)=>{if(!u)throw new Error("Engine not initialized");try{const r=await p(e,t);return P(),r}catch(e){const t=e instanceof Error?e.message:String(e);throw M(t),e}},[u]),P=t.useCallback(()=>{if(!u)return v(null),null;try{const e=S();return v(e),C(e.engineState),e}catch{return null}},[u]),b=t.useCallback(()=>{M(null)},[]);return t.useEffect(()=>{!r||u||l||T()},[r,u,l,T]),t.useEffect(()=>{if(!u)return;const e=setInterval(()=>{try{const e=w();C(e)}catch{}},1e3);return()=>clearInterval(e)},[u]),t.useEffect(()=>()=>{u&&R(!0).catch(console.error)},[]),{isInitialized:u,isLoading:l,error:m,engineState:E,metrics:k,diagnostics:I,initialize:T,destroy:R,processStream:x,processStreamChunked:L,getDiagnostics:P,resetError:b}}class E{constructor(){this.name="RNNoise",this.description="Neural network-based noise suppression",this.isInitialized=!1,this.module=null,this.state=null,this.inputPtr=0,this.outputPtr=0}async initialize(){if(this.isInitialized)return;console.log("[RNNoiseEngine] Starting initialization...");const e=document.createElement("script");e.src="/rnnoise-fixed.js",await new Promise((t,r)=>{e.onload=t,e.onerror=r,document.head.appendChild(e)});const t=window.createRNNWasmModule;if(this.module=await t({locateFile:e=>e.endsWith(".wasm")?`/dist/${e}`:e}),this.state=this.module._rnnoise_create(0),!this.state)throw new Error("Failed to create RNNoise state");this.inputPtr=this.module._malloc(1920),this.outputPtr=this.module._malloc(1920);const r=new Float32Array(480);for(let e=0;e<10;e++)this.module.HEAPF32.set(r,this.inputPtr>>2),this.module._rnnoise_process_frame(this.state,this.outputPtr,this.inputPtr);this.isInitialized=!0,console.log("[RNNoiseEngine] Initialization complete!")}process(e){if(!this.isInitialized)throw new Error("RNNoiseEngine not initialized");if(480!==e.length)throw new Error("RNNoise requires exactly 480 samples per frame");this.module.HEAPF32.set(e,this.inputPtr>>2),this.module._rnnoise_process_frame(this.state,this.outputPtr,this.inputPtr);const t=new Float32Array(480);for(let e=0;e<480;e++)t[e]=this.module.HEAPF32[(this.outputPtr>>2)+e];return t}cleanup(){this.module&&this.state&&(this.module._free(this.inputPtr),this.module._free(this.outputPtr),this.module._rnnoise_destroy(this.state),this.state=null,this.module=null,this.isInitialized=!1)}}const C=(e={engineType:"rnnoise"})=>{console.warn("[Murmuraba] useAudioEngine is deprecated. Please use useMurmubaraEngine instead for better React 19 compatibility.");const[r,i]=t.useState(!1),[s,n]=t.useState(!1),[a,o]=t.useState(null),u=t.useRef(null),c=t.useRef(null),l=t.useRef(null),h=t.useRef(null),d=t.useRef({inputSamples:0,outputSamples:0,silenceFrames:0,activeFrames:0,totalInputEnergy:0,totalOutputEnergy:0,peakInput:0,peakOutput:0,startTime:0,totalFrames:0}),m=async()=>{if(!r&&!s){n(!0),o(null);try{console.log("[AudioEngine] Creating audio engine with config:",e);const t=function(e){switch(e.engineType){case"rnnoise":return new E;case"speex":throw new Error("Speex engine not implemented yet");case"custom":throw new Error("Custom engine not implemented yet");default:throw new Error(`Unknown engine type: ${e.engineType}`)}}(e);await t.initialize(),l.current=t,h.current={inputBuffer:[],outputBuffer:[],energyHistory:new Array(20).fill(0),energyIndex:0},console.log("[AudioEngine] Engine ready for processing"),u.current=new AudioContext({sampleRate:48e3});const r=u.current.createScriptProcessor(4096,1,1);r.onaudioprocess=e=>{const t=e.inputBuffer.getChannelData(0),r=e.outputBuffer.getChannelData(0);if(l.current&&h.current){d.current.inputSamples+=t.length;for(let e=0;e<t.length;e++)h.current.inputBuffer.push(t[e]),d.current.peakInput=Math.max(d.current.peakInput,Math.abs(t[e]));for(;h.current.inputBuffer.length>=480;){const e=h.current.inputBuffer.splice(0,480),t=new Float32Array(e),r=l.current.process(t),i=k(t),s=k(r);d.current.totalFrames++,d.current.totalInputEnergy+=i,d.current.totalOutputEnergy+=s,h.current.energyHistory[h.current.energyIndex]=i,h.current.energyIndex=(h.current.energyIndex+1)%20;const n=h.current.energyHistory.reduce((e,t)=>e+t)/20;let a=r;const o=.001,u=.005;let c=!1;if(n<o)a=a.map(e=>.1*e),c=!0,d.current.silenceFrames++;else if(n<u){const e=.1+.9*((n-o)/(u-o));a=a.map(t=>t*e),d.current.activeFrames++}else d.current.activeFrames++;const m=s/(i+1e-4);if(m<.3&&n<u&&(a=a.map(e=>e*m),c||d.current.silenceFrames++),Math.random()<.02){const e=n<o?"SILENCE":n<u?"TRANSITION":"SPEECH";console.log("[AudioEngine]","\n  Status:",e,"\n  Avg Energy:",n.toFixed(6),"\n  Frame Energy:",i.toFixed(6),"\n  Engine Reduction:",(100*(1-m)).toFixed(1)+"%","\n  Gate Applied:",n<u?"Yes":"No")}for(let e=0;e<480;e++)h.current.outputBuffer.push(a[e])}for(let e=0;e<r.length;e++)if(h.current.outputBuffer.length>0){const t=h.current.outputBuffer.shift();r[e]=t,d.current.outputSamples++,d.current.peakOutput=Math.max(d.current.peakOutput,Math.abs(t))}else r[e]=0}else r.set(t)},c.current=r,i(!0),console.log("[AudioEngine] Initialization complete!")}catch(e){throw console.error("[AudioEngine] Error:",e),o(e instanceof Error?e.message:String(e)),e}finally{n(!1)}}},g=()=>{d.current={inputSamples:0,outputSamples:0,silenceFrames:0,activeFrames:0,totalInputEnergy:0,totalOutputEnergy:0,peakInput:0,peakOutput:0,startTime:Date.now(),totalFrames:0}};return{isInitialized:r,isLoading:s,error:a,processStream:async e=>{if(r||await m(),!u.current||!c.current)throw new Error("Not initialized");g();const t=u.current.createMediaStreamSource(e),i=u.current.createMediaStreamDestination();return t.connect(c.current),c.current.connect(i),i.stream},cleanup:()=>{c.current&&c.current.disconnect(),l.current&&(l.current.cleanup(),l.current=null),u.current&&"closed"!==u.current.state&&u.current.close()},initializeAudioEngine:m,getMetrics:()=>{const e=d.current,t=Date.now()-e.startTime,r=e.totalFrames>0?e.totalInputEnergy/e.totalFrames:0,i=e.totalFrames>0?e.totalOutputEnergy/e.totalFrames:0,s=100*(.5*(r>0?Math.abs(r-i)/r:0)+.5*(e.totalFrames>0?e.silenceFrames/e.totalFrames:0));return{inputSamples:e.inputSamples,outputSamples:e.outputSamples,noiseReductionLevel:Math.max(0,Math.min(100,s)),silenceFrames:e.silenceFrames,activeFrames:e.activeFrames,averageInputEnergy:r,averageOutputEnergy:i,peakInputLevel:e.peakInput,peakOutputLevel:e.peakOutput,processingTimeMs:t,chunkOffset:0,totalFramesProcessed:e.totalFrames}},resetMetrics:g}};function k(e){let t=0;for(let r=0;r<e.length;r++)t+=e[r]*e[r];return Math.sqrt(t/e.length)}const A="1.3.0",I=A;var v={useMurmubaraEngine:M,useAudioEngine:C,MurmubaraEngine:l};e.ErrorCodes=a,e.EventEmitter=r,e.Logger=s,e.MURMURABA_VERSION=I,e.MetricsManager=u,e.MurmubaraEngine=l,e.MurmubaraError=n,e.StateManager=i,e.VERSION=A,e.WorkerManager=o,e.default=v,e.destroyEngine=f,e.getDiagnostics=S,e.getEngine=m,e.getEngineStatus=w,e.initializeAudioEngine=d,e.onMetricsUpdate=y,e.processStream=g,e.processStreamChunked=p,e.useAudioEngine=C,e.useMurmubaraEngine=M,Object.defineProperty(e,"__esModule",{value:!0})});
//# sourceMappingURL=index.umd.min.js.map
