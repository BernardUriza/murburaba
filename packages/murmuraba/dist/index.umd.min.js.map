{"version":3,"file":"index.umd.min.js","sources":["../src/core/EventEmitter.ts","../src/core/StateManager.ts","../src/core/Logger.ts","../src/types/audio-types.ts","../src/managers/WorkerManager.ts","../src/managers/MetricsManager.ts","../src/managers/ChunkProcessor.ts","../src/core/MurmubaraEngine.ts","../src/api.ts","../src/index.ts","../src/hooks/useMurmubaraEngine.ts"],"sourcesContent":["export type EventHandler = (...args: any[]) => void;\n\nexport class EventEmitter<T extends Record<string, EventHandler>> {\n  private events: Map<keyof T, Set<EventHandler>> = new Map();\n  \n  on<K extends keyof T>(event: K, handler: T[K]): void {\n    if (!this.events.has(event)) {\n      this.events.set(event, new Set());\n    }\n    this.events.get(event)!.add(handler);\n  }\n  \n  off<K extends keyof T>(event: K, handler: T[K]): void {\n    const handlers = this.events.get(event);\n    if (handlers) {\n      handlers.delete(handler);\n      if (handlers.size === 0) {\n        this.events.delete(event);\n      }\n    }\n  }\n  \n  emit<K extends keyof T>(event: K, ...args: Parameters<T[K]>): void {\n    const handlers = this.events.get(event);\n    if (handlers) {\n      handlers.forEach(handler => {\n        try {\n          handler(...args);\n        } catch (error) {\n          console.error(`Error in event handler for ${String(event)}:`, error);\n        }\n      });\n    }\n  }\n  \n  once<K extends keyof T>(event: K, handler: T[K]): void {\n    const wrappedHandler = ((...args: any[]) => {\n      this.off(event, wrappedHandler as T[K]);\n      handler(...args);\n    }) as T[K];\n    this.on(event, wrappedHandler);\n  }\n  \n  removeAllListeners(event?: keyof T): void {\n    if (event) {\n      this.events.delete(event);\n    } else {\n      this.events.clear();\n    }\n  }\n  \n  listenerCount(event: keyof T): number {\n    const handlers = this.events.get(event);\n    return handlers ? handlers.size : 0;\n  }\n}","import { EngineState } from '../types';\nimport { EventEmitter } from './EventEmitter';\n\ninterface StateEvents {\n  'state-change': (oldState: EngineState, newState: EngineState) => void;\n  [key: string]: (...args: any[]) => void;\n}\n\nexport class StateManager extends EventEmitter<StateEvents> {\n  private currentState: EngineState = 'uninitialized';\n  private allowedTransitions: Map<EngineState, EngineState[]> = new Map([\n    ['uninitialized', ['initializing', 'error']],\n    ['initializing', ['ready', 'error']],\n    ['ready', ['processing', 'destroying', 'error']],\n    ['processing', ['ready', 'paused', 'destroying', 'error']],\n    ['paused', ['processing', 'ready', 'destroying', 'error']],\n    ['destroying', ['destroyed', 'error']],\n    ['destroyed', []],\n    ['error', ['initializing', 'destroying']],\n  ]);\n  \n  getState(): EngineState {\n    return this.currentState;\n  }\n  \n  canTransitionTo(newState: EngineState): boolean {\n    const allowed = this.allowedTransitions.get(this.currentState) || [];\n    return allowed.includes(newState);\n  }\n  \n  transitionTo(newState: EngineState): boolean {\n    if (!this.canTransitionTo(newState)) {\n      console.warn(\n        `Invalid state transition: ${this.currentState} -> ${newState}`\n      );\n      return false;\n    }\n    \n    const oldState = this.currentState;\n    this.currentState = newState;\n    this.emit('state-change', oldState, newState);\n    return true;\n  }\n  \n  isInState(...states: EngineState[]): boolean {\n    return states.includes(this.currentState);\n  }\n  \n  requireState(...states: EngineState[]): void {\n    if (!this.isInState(...states)) {\n      throw new Error(\n        `Operation requires state to be one of: ${states.join(', ')}, ` +\n        `but current state is: ${this.currentState}`\n      );\n    }\n  }\n  \n  reset(): void {\n    const oldState = this.currentState;\n    this.currentState = 'uninitialized';\n    if (oldState !== 'uninitialized') {\n      this.emit('state-change', oldState, 'uninitialized');\n    }\n  }\n}","import { LogLevel } from '../types';\n\nexport class Logger {\n  private level: LogLevel = 'info';\n  private onLog?: (level: LogLevel, message: string, data?: any) => void;\n  private prefix: string;\n  \n  constructor(prefix: string = '[Murmuraba]') {\n    this.prefix = prefix;\n  }\n  \n  setLevel(level: LogLevel): void {\n    this.level = level;\n  }\n  \n  setLogHandler(handler: (level: LogLevel, message: string, data?: any) => void): void {\n    this.onLog = handler;\n  }\n  \n  private shouldLog(level: LogLevel): boolean {\n    const levels: LogLevel[] = ['none', 'error', 'warn', 'info', 'debug'];\n    const currentIndex = levels.indexOf(this.level);\n    const messageIndex = levels.indexOf(level);\n    return currentIndex > 0 && messageIndex <= currentIndex;\n  }\n  \n  private log(level: LogLevel, message: string, data?: any): void {\n    if (!this.shouldLog(level)) return;\n    \n    const timestamp = new Date().toISOString();\n    const formattedMessage = `${this.prefix} [${timestamp}] [${level.toUpperCase()}] ${message}`;\n    \n    if (this.onLog) {\n      this.onLog(level, formattedMessage, data);\n    } else {\n      const logMethod = level === 'error' ? console.error : \n                       level === 'warn' ? console.warn : \n                       console.log;\n      \n      if (data !== undefined) {\n        logMethod(formattedMessage, data);\n      } else {\n        logMethod(formattedMessage);\n      }\n    }\n  }\n  \n  error(message: string, data?: any): void {\n    this.log('error', message, data);\n  }\n  \n  warn(message: string, data?: any): void {\n    this.log('warn', message, data);\n  }\n  \n  info(message: string, data?: any): void {\n    this.log('info', message, data);\n  }\n  \n  debug(message: string, data?: any): void {\n    this.log('debug', message, data);\n  }\n}","export type EngineState = \n  | 'uninitialized'\n  | 'initializing' \n  | 'ready'\n  | 'processing'\n  | 'paused'\n  | 'destroying'\n  | 'destroyed'\n  | 'error';\n\nexport type LogLevel = 'none' | 'error' | 'warn' | 'info' | 'debug';\nexport type NoiseReductionLevel = 'low' | 'medium' | 'high' | 'auto';\nexport type Algorithm = 'rnnoise' | 'spectral' | 'adaptive';\nexport type BufferSize = 256 | 512 | 1024 | 2048 | 4096;\n\nexport interface MurmubaraConfig {\n  logLevel?: LogLevel;\n  onLog?: (level: LogLevel, message: string, data?: any) => void;\n  noiseReductionLevel?: NoiseReductionLevel;\n  bufferSize?: BufferSize;\n  algorithm?: Algorithm;\n  autoCleanup?: boolean;\n  cleanupDelay?: number;\n  useWorker?: boolean;\n  workerPath?: string;\n}\n\nexport interface StreamController {\n  stream: MediaStream;\n  processor: AudioProcessor;\n  stop: () => void;\n  pause: () => void;\n  resume: () => void;\n  getState: () => EngineState;\n}\n\nexport interface AudioProcessor {\n  id: string;\n  state: EngineState;\n  inputNode?: AudioNode;\n  outputNode?: AudioNode;\n}\n\nexport interface ProcessingMetrics {\n  noiseReductionLevel: number;\n  processingLatency: number;\n  inputLevel: number;\n  outputLevel: number;\n  timestamp: number;\n  frameCount: number;\n  droppedFrames: number;\n}\n\nexport interface ChunkMetrics {\n  originalSize: number;\n  processedSize: number;\n  noiseRemoved: number;\n  metrics: ProcessingMetrics;\n  duration: number;\n  startTime: number;\n  endTime: number;\n}\n\nexport interface ChunkConfig {\n  chunkDuration: number;\n  onChunkProcessed?: (chunk: ChunkMetrics) => void;\n  overlap?: number;\n}\n\nexport interface DiagnosticInfo {\n  engineVersion: string;\n  wasmLoaded: boolean;\n  activeProcessors: number;\n  memoryUsage: number;\n  processingTime: number;\n  engineState: EngineState;\n  errors: Array<{ timestamp: number; error: string }>;\n}\n\nexport interface EngineEvents {\n  initialized: () => void;\n  'processing-start': () => void;\n  'processing-end': () => void;\n  destroyed: () => void;\n  error: (error: MurmubaraError) => void;\n  'state-change': (oldState: EngineState, newState: EngineState) => void;\n  'metrics-update': (metrics: ProcessingMetrics) => void;\n  [key: string]: (...args: any[]) => void;\n}\n\nexport class MurmubaraError extends Error {\n  code: string;\n  details?: any;\n\n  constructor(code: string, message: string, details?: any) {\n    super(message);\n    this.name = 'MurmubaraError';\n    this.code = code;\n    this.details = details;\n  }\n}\n\nexport const ErrorCodes = {\n  WASM_NOT_LOADED: 'WASM_NOT_LOADED',\n  INVALID_STREAM: 'INVALID_STREAM',\n  ENGINE_BUSY: 'ENGINE_BUSY',\n  INITIALIZATION_FAILED: 'INITIALIZATION_FAILED',\n  PROCESSING_FAILED: 'PROCESSING_FAILED',\n  CLEANUP_FAILED: 'CLEANUP_FAILED',\n  WORKER_ERROR: 'WORKER_ERROR',\n  INVALID_CONFIG: 'INVALID_CONFIG',\n  NOT_INITIALIZED: 'NOT_INITIALIZED',\n  ALREADY_INITIALIZED: 'ALREADY_INITIALIZED',\n} as const;","import { Logger } from '../core/Logger';\nimport { MurmubaraError, ErrorCodes } from '../types';\n\ninterface WorkerMessage {\n  type: string;\n  payload?: any;\n}\n\nexport class WorkerManager {\n  private workers: Map<string, Worker> = new Map();\n  private logger: Logger;\n  \n  constructor(logger: Logger) {\n    this.logger = logger;\n  }\n  \n  createWorker(id: string, workerPath: string): Worker {\n    if (this.workers.has(id)) {\n      throw new MurmubaraError(\n        ErrorCodes.WORKER_ERROR,\n        `Worker with id ${id} already exists`\n      );\n    }\n    \n    try {\n      const worker = new Worker(workerPath);\n      this.workers.set(id, worker);\n      this.logger.debug(`Worker created: ${id}`);\n      return worker;\n    } catch (error) {\n      this.logger.error(`Failed to create worker: ${id}`, error);\n      throw new MurmubaraError(\n        ErrorCodes.WORKER_ERROR,\n        `Failed to create worker: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  }\n  \n  getWorker(id: string): Worker | undefined {\n    return this.workers.get(id);\n  }\n  \n  sendMessage(id: string, message: WorkerMessage): void {\n    const worker = this.workers.get(id);\n    if (!worker) {\n      throw new MurmubaraError(\n        ErrorCodes.WORKER_ERROR,\n        `Worker ${id} not found`\n      );\n    }\n    \n    worker.postMessage(message);\n    this.logger.debug(`Message sent to worker ${id}:`, message);\n  }\n  \n  terminateWorker(id: string): void {\n    const worker = this.workers.get(id);\n    if (worker) {\n      worker.terminate();\n      this.workers.delete(id);\n      this.logger.debug(`Worker terminated: ${id}`);\n    }\n  }\n  \n  terminateAll(): void {\n    this.logger.info(`Terminating all ${this.workers.size} workers`);\n    for (const [id, worker] of this.workers) {\n      worker.terminate();\n      this.logger.debug(`Worker terminated: ${id}`);\n    }\n    this.workers.clear();\n  }\n  \n  getActiveWorkerCount(): number {\n    return this.workers.size;\n  }\n  \n  getWorkerIds(): string[] {\n    return Array.from(this.workers.keys());\n  }\n}","import { ProcessingMetrics, ChunkMetrics } from '../types';\nimport { EventEmitter } from '../core/EventEmitter';\n\ninterface MetricsEvents {\n  'metrics-update': (metrics: ProcessingMetrics) => void;\n  'chunk-processed': (chunk: ChunkMetrics) => void;\n  [key: string]: (...args: any[]) => void;\n}\n\nexport class MetricsManager extends EventEmitter<MetricsEvents> {\n  private metrics: ProcessingMetrics = {\n    noiseReductionLevel: 0,\n    processingLatency: 0,\n    inputLevel: 0,\n    outputLevel: 0,\n    timestamp: Date.now(),\n    frameCount: 0,\n    droppedFrames: 0,\n  };\n  \n  private updateInterval?: NodeJS.Timeout;\n  private frameTimestamps: number[] = [];\n  private maxFrameHistory = 100;\n  \n  startAutoUpdate(intervalMs: number = 100): void {\n    this.stopAutoUpdate();\n    this.updateInterval = setInterval(() => {\n      this.calculateLatency();\n      this.emit('metrics-update', { ...this.metrics });\n    }, intervalMs);\n  }\n  \n  stopAutoUpdate(): void {\n    if (this.updateInterval) {\n      clearInterval(this.updateInterval);\n      this.updateInterval = undefined;\n    }\n  }\n  \n  updateInputLevel(level: number): void {\n    this.metrics.inputLevel = Math.max(0, Math.min(1, level));\n  }\n  \n  updateOutputLevel(level: number): void {\n    this.metrics.outputLevel = Math.max(0, Math.min(1, level));\n  }\n  \n  updateNoiseReduction(level: number): void {\n    this.metrics.noiseReductionLevel = Math.max(0, Math.min(100, level));\n  }\n  \n  recordFrame(timestamp: number = Date.now()): void {\n    this.frameTimestamps.push(timestamp);\n    if (this.frameTimestamps.length > this.maxFrameHistory) {\n      this.frameTimestamps.shift();\n    }\n    this.metrics.frameCount++;\n    this.metrics.timestamp = timestamp;\n  }\n  \n  recordDroppedFrame(): void {\n    this.metrics.droppedFrames++;\n  }\n  \n  recordChunk(chunk: ChunkMetrics): void {\n    this.emit('chunk-processed', chunk);\n  }\n  \n  private calculateLatency(): void {\n    if (this.frameTimestamps.length < 2) {\n      this.metrics.processingLatency = 0;\n      return;\n    }\n    \n    const deltas: number[] = [];\n    for (let i = 1; i < this.frameTimestamps.length; i++) {\n      deltas.push(this.frameTimestamps[i] - this.frameTimestamps[i - 1]);\n    }\n    \n    const avgDelta = deltas.reduce((a, b) => a + b, 0) / deltas.length;\n    this.metrics.processingLatency = avgDelta;\n  }\n  \n  getMetrics(): ProcessingMetrics {\n    return { ...this.metrics };\n  }\n  \n  reset(): void {\n    this.metrics = {\n      noiseReductionLevel: 0,\n      processingLatency: 0,\n      inputLevel: 0,\n      outputLevel: 0,\n      timestamp: Date.now(),\n      frameCount: 0,\n      droppedFrames: 0,\n    };\n    this.frameTimestamps = [];\n  }\n  \n  calculateRMS(samples: Float32Array): number {\n    let sum = 0;\n    for (let i = 0; i < samples.length; i++) {\n      sum += samples[i] * samples[i];\n    }\n    return Math.sqrt(sum / samples.length);\n  }\n  \n  calculatePeak(samples: Float32Array): number {\n    let peak = 0;\n    for (let i = 0; i < samples.length; i++) {\n      peak = Math.max(peak, Math.abs(samples[i]));\n    }\n    return peak;\n  }\n}","import { EventEmitter } from '../core/EventEmitter';\nimport { Logger } from '../core/Logger';\nimport { ChunkMetrics, ChunkConfig, ProcessingMetrics } from '../types';\nimport { MetricsManager } from './MetricsManager';\n\ninterface ChunkEvents {\n  'chunk-ready': (chunk: AudioChunk) => void;\n  'chunk-processed': (metrics: ChunkMetrics) => void;\n  [key: string]: (...args: any[]) => void;\n}\n\ninterface AudioChunk {\n  id: string;\n  data: Float32Array;\n  startTime: number;\n  endTime: number;\n  sampleRate: number;\n  channelCount: number;\n}\n\nexport class ChunkProcessor extends EventEmitter<ChunkEvents> {\n  private logger: Logger;\n  private config: Required<ChunkConfig>;\n  private currentChunk: Float32Array[] = [];\n  private chunkStartTime: number = Date.now();\n  private chunkIndex: number = 0;\n  private sampleRate: number;\n  private samplesPerChunk: number;\n  private currentSampleCount: number = 0;\n  private overlapBuffer: Float32Array[] = [];\n  private metricsManager: MetricsManager;\n  \n  constructor(\n    sampleRate: number,\n    config: ChunkConfig,\n    logger: Logger,\n    metricsManager: MetricsManager\n  ) {\n    super();\n    this.logger = logger;\n    this.sampleRate = sampleRate;\n    this.metricsManager = metricsManager;\n    \n    this.config = {\n      chunkDuration: config.chunkDuration,\n      onChunkProcessed: config.onChunkProcessed || undefined,\n      overlap: config.overlap || 0,\n    } as Required<ChunkConfig>;\n    \n    // Calculate samples per chunk\n    this.samplesPerChunk = Math.floor(\n      (this.config.chunkDuration / 1000) * this.sampleRate\n    );\n    \n    this.logger.info(`ChunkProcessor initialized:`, {\n      sampleRate: this.sampleRate,\n      chunkDuration: this.config.chunkDuration,\n      samplesPerChunk: this.samplesPerChunk,\n      overlap: this.config.overlap,\n    });\n  }\n  \n  /**\n   * Add samples to the current chunk\n   */\n  addSamples(samples: Float32Array): void {\n    // Initialize start time on first sample if not already set\n    if (this.chunkStartTime === 0) {\n      this.chunkStartTime = Date.now();\n    }\n    \n    this.currentChunk.push(new Float32Array(samples));\n    this.currentSampleCount += samples.length;\n    \n    // Check if we have enough samples for a chunk\n    while (this.currentSampleCount >= this.samplesPerChunk) {\n      this.processCurrentChunk();\n    }\n  }\n  \n  /**\n   * Process the current chunk\n   */\n  private processCurrentChunk(): void {\n    const chunkId = `chunk-${this.chunkIndex++}`;\n    const endTime = Date.now();\n    \n    // Combine all samples into a single array\n    const totalSamples = this.extractChunkSamples();\n    \n    // Apply overlap if configured\n    const processedSamples = this.applyOverlap(totalSamples);\n    \n    // Create chunk object\n    const chunk: AudioChunk = {\n      id: chunkId,\n      data: processedSamples,\n      startTime: this.chunkStartTime,\n      endTime: endTime,\n      sampleRate: this.sampleRate,\n      channelCount: 1,\n    };\n    \n    // Emit chunk ready event\n    this.emit('chunk-ready', chunk);\n    \n    // Calculate and emit metrics\n    this.emitChunkMetrics(chunk, totalSamples, processedSamples);\n    \n    // Reset for next chunk\n    this.chunkStartTime = endTime;\n  }\n  \n  /**\n   * Extract samples for current chunk\n   */\n  private extractChunkSamples(): Float32Array {\n    const result = new Float32Array(this.samplesPerChunk);\n    let offset = 0;\n    let remainingSamples = this.samplesPerChunk;\n    \n    while (remainingSamples > 0 && this.currentChunk.length > 0) {\n      const buffer = this.currentChunk[0];\n      const samplesToTake = Math.min(remainingSamples, buffer.length);\n      \n      // Copy samples\n      result.set(buffer.subarray(0, samplesToTake), offset);\n      offset += samplesToTake;\n      remainingSamples -= samplesToTake;\n      \n      if (samplesToTake === buffer.length) {\n        // Used entire buffer\n        this.currentChunk.shift();\n      } else {\n        // Partial buffer used, keep remainder\n        this.currentChunk[0] = buffer.subarray(samplesToTake);\n      }\n    }\n    \n    this.currentSampleCount -= this.samplesPerChunk;\n    return result;\n  }\n  \n  /**\n   * Apply overlap window to smooth chunk transitions\n   */\n  private applyOverlap(samples: Float32Array): Float32Array {\n    if (this.config.overlap === 0) {\n      return samples;\n    }\n    \n    const overlapSamples = Math.floor(this.samplesPerChunk * this.config.overlap);\n    const result = new Float32Array(samples.length);\n    \n    // Copy main samples\n    result.set(samples);\n    \n    // Apply overlap from previous chunk\n    if (this.overlapBuffer.length > 0) {\n      const previousOverlap = this.combineBuffers(this.overlapBuffer);\n      const fadeLength = Math.min(overlapSamples, previousOverlap.length);\n      \n      // Crossfade between chunks\n      for (let i = 0; i < fadeLength; i++) {\n        const fadeIn = i / fadeLength;\n        const fadeOut = 1 - fadeIn;\n        result[i] = result[i] * fadeIn + previousOverlap[i] * fadeOut;\n      }\n    }\n    \n    // Save overlap for next chunk\n    this.overlapBuffer = [samples.subarray(samples.length - overlapSamples)];\n    \n    return result;\n  }\n  \n  /**\n   * Calculate and emit chunk metrics\n   */\n  private emitChunkMetrics(\n    chunk: AudioChunk,\n    originalSamples: Float32Array,\n    processedSamples: Float32Array\n  ): void {\n    // Calculate metrics\n    const originalRMS = this.metricsManager.calculateRMS(originalSamples);\n    const processedRMS = this.metricsManager.calculateRMS(processedSamples);\n    const originalPeak = this.metricsManager.calculatePeak(originalSamples);\n    const processedPeak = this.metricsManager.calculatePeak(processedSamples);\n    \n    const noiseRemoved = originalRMS > 0 \n      ? ((originalRMS - processedRMS) / originalRMS) * 100 \n      : 0;\n    \n    const metrics: ChunkMetrics = {\n      originalSize: originalSamples.length * 4, // Float32 = 4 bytes\n      processedSize: processedSamples.length * 4,\n      noiseRemoved: Math.max(0, Math.min(100, noiseRemoved)),\n      metrics: {\n        noiseReductionLevel: noiseRemoved,\n        processingLatency: chunk.endTime - chunk.startTime,\n        inputLevel: originalPeak,\n        outputLevel: processedPeak,\n        timestamp: chunk.endTime,\n        frameCount: Math.floor(processedSamples.length / 480), // RNNoise frame size\n        droppedFrames: 0,\n      },\n      duration: this.config.chunkDuration,\n      startTime: chunk.startTime,\n      endTime: chunk.endTime,\n    };\n    \n    // Emit to listeners\n    this.emit('chunk-processed', metrics);\n    \n    // Call user callback if provided\n    if (this.config.onChunkProcessed) {\n      try {\n        this.config.onChunkProcessed(metrics);\n      } catch (error) {\n        this.logger.error('Error in chunk processed callback:', error);\n      }\n    }\n    \n    this.logger.debug(`Chunk ${chunk.id} processed:`, {\n      duration: `${metrics.duration}ms`,\n      noiseRemoved: `${metrics.noiseRemoved.toFixed(1)}%`,\n      latency: `${metrics.metrics.processingLatency}ms`,\n    });\n  }\n  \n  /**\n   * Force process remaining samples as final chunk\n   */\n  flush(): void {\n    if (this.currentSampleCount > 0) {\n      this.logger.info(`Flushing final chunk with ${this.currentSampleCount} samples`);\n      \n      // Pad with silence if needed\n      const remainingSamples = this.samplesPerChunk - this.currentSampleCount;\n      if (remainingSamples > 0) {\n        this.addSamples(new Float32Array(remainingSamples));\n      }\n      \n      this.processCurrentChunk();\n    }\n    \n    this.reset();\n  }\n  \n  /**\n   * Reset the processor\n   */\n  reset(): void {\n    this.currentChunk = [];\n    this.overlapBuffer = [];\n    this.currentSampleCount = 0;\n    this.chunkIndex = 0;\n    this.chunkStartTime = Date.now();\n    this.logger.debug('ChunkProcessor reset');\n  }\n  \n  /**\n   * Combine multiple buffers into one\n   */\n  private combineBuffers(buffers: Float32Array[]): Float32Array {\n    const totalLength = buffers.reduce((sum, buf) => sum + buf.length, 0);\n    const result = new Float32Array(totalLength);\n    let offset = 0;\n    \n    for (const buffer of buffers) {\n      result.set(buffer, offset);\n      offset += buffer.length;\n    }\n    \n    return result;\n  }\n  \n  /**\n   * Get current buffer status\n   */\n  getStatus(): {\n    currentSampleCount: number;\n    samplesPerChunk: number;\n    chunkIndex: number;\n    bufferFillPercentage: number;\n  } {\n    return {\n      currentSampleCount: this.currentSampleCount,\n      samplesPerChunk: this.samplesPerChunk,\n      chunkIndex: this.chunkIndex,\n      bufferFillPercentage: (this.currentSampleCount / this.samplesPerChunk) * 100,\n    };\n  }\n}","import { EventEmitter } from './EventEmitter';\nimport { StateManager } from './StateManager';\nimport { Logger } from './Logger';\nimport { WorkerManager } from '../managers/WorkerManager';\nimport { MetricsManager } from '../managers/MetricsManager';\nimport { ChunkProcessor } from '../managers/ChunkProcessor';\nimport {\n  MurmubaraConfig,\n  EngineEvents,\n  StreamController,\n  DiagnosticInfo,\n  MurmubaraError,\n  ErrorCodes,\n  ProcessingMetrics,\n  ChunkConfig,\n  EngineState,\n} from '../types';\n\nexport class MurmubaraEngine extends EventEmitter<EngineEvents> {\n  private config: Required<MurmubaraConfig>;\n  private stateManager: StateManager;\n  private logger: Logger;\n  private workerManager: WorkerManager;\n  private metricsManager: MetricsManager;\n  private audioContext?: AudioContext;\n  private activeStreams: Map<string, StreamController> = new Map();\n  private wasmModule?: any;\n  private rnnoiseState?: any;\n  private inputPtr?: number;\n  private outputPtr?: number;\n  private initPromise?: Promise<void>;\n  private cleanupTimer?: NodeJS.Timeout;\n  private errorHistory: Array<{ timestamp: number; error: string }> = [];\n  \n  constructor(config: MurmubaraConfig = {}) {\n    super();\n    \n    this.config = {\n      logLevel: config.logLevel || 'info',\n      onLog: config.onLog || undefined,\n      noiseReductionLevel: config.noiseReductionLevel || 'medium',\n      bufferSize: config.bufferSize || 4096,\n      algorithm: config.algorithm || 'rnnoise',\n      autoCleanup: config.autoCleanup ?? true,\n      cleanupDelay: config.cleanupDelay || 30000,\n      useWorker: config.useWorker ?? false,\n      workerPath: config.workerPath || '/murmuraba.worker.js',\n    } as Required<MurmubaraConfig>;\n    \n    this.logger = new Logger('[Murmuraba]');\n    this.logger.setLevel(this.config.logLevel);\n    if (this.config.onLog) {\n      this.logger.setLogHandler(this.config.onLog);\n    }\n    \n    this.stateManager = new StateManager();\n    this.workerManager = new WorkerManager(this.logger);\n    this.metricsManager = new MetricsManager();\n    \n    this.setupEventForwarding();\n    this.setupAutoCleanup();\n  }\n  \n  private setupEventForwarding(): void {\n    this.stateManager.on('state-change', (oldState, newState) => {\n      this.logger.info(`State transition: ${oldState} -> ${newState}`);\n      this.emit('state-change', oldState, newState);\n    });\n    \n    this.metricsManager.on('metrics-update', (metrics) => {\n      this.emit('metrics-update', metrics);\n    });\n  }\n  \n  private setupAutoCleanup(): void {\n    if (!this.config.autoCleanup) return;\n    \n    const resetCleanupTimer = () => {\n      if (this.cleanupTimer) {\n        clearTimeout(this.cleanupTimer);\n      }\n      \n      if (this.activeStreams.size === 0 && this.stateManager.isInState('ready')) {\n        this.cleanupTimer = setTimeout(() => {\n          this.logger.info('Auto-cleanup triggered due to inactivity');\n          this.destroy();\n        }, this.config.cleanupDelay);\n      }\n    };\n    \n    this.on('processing-start', () => {\n      if (this.cleanupTimer) {\n        clearTimeout(this.cleanupTimer);\n        this.cleanupTimer = undefined;\n      }\n    });\n    \n    this.on('processing-end', resetCleanupTimer);\n  }\n  \n  async initialize(): Promise<void> {\n    if (this.initPromise) {\n      return this.initPromise;\n    }\n    \n    if (!this.stateManager.canTransitionTo('initializing')) {\n      throw new MurmubaraError(\n        ErrorCodes.ALREADY_INITIALIZED,\n        'Engine is already initialized or in an invalid state'\n      );\n    }\n    \n    this.initPromise = this.performInitialization();\n    return this.initPromise;\n  }\n  \n  private async performInitialization(): Promise<void> {\n    this.stateManager.transitionTo('initializing');\n    \n    try {\n      this.logger.info('Initializing Murmuraba engine...');\n      \n      // Create audio context\n      this.audioContext = new AudioContext({ sampleRate: 48000 });\n      \n      // Load WASM module\n      await this.loadWasmModule();\n      \n      // Initialize metrics\n      this.metricsManager.startAutoUpdate(100);\n      \n      this.stateManager.transitionTo('ready');\n      this.emit('initialized');\n      this.logger.info('Murmuraba engine initialized successfully');\n      \n    } catch (error) {\n      this.stateManager.transitionTo('error');\n      const murmubaraError = new MurmubaraError(\n        ErrorCodes.INITIALIZATION_FAILED,\n        `Initialization failed: ${error instanceof Error ? error.message : String(error)}`,\n        error\n      );\n      this.emit('error', murmubaraError);\n      throw murmubaraError;\n    }\n  }\n  \n  private async loadWasmModule(): Promise<void> {\n    this.logger.debug('Loading WASM module...');\n    \n    // Load the RNNoise script\n    const script = document.createElement('script');\n    script.src = '/rnnoise-fixed.js';\n    \n    await new Promise<void>((resolve, reject) => {\n      script.onload = () => resolve();\n      script.onerror = () => reject(new Error('Failed to load RNNoise script'));\n      document.head.appendChild(script);\n    });\n    \n    // Create WASM module\n    const createRNNWasmModule = (window as any).createRNNWasmModule;\n    if (!createRNNWasmModule) {\n      throw new Error('RNNoise WASM module creator not found');\n    }\n    \n    this.wasmModule = await createRNNWasmModule({\n      locateFile: (filename: string) => {\n        if (filename.endsWith('.wasm')) {\n          return `/dist/${filename}`;\n        }\n        return filename;\n      }\n    });\n    \n    // Create RNNoise state\n    this.rnnoiseState = this.wasmModule._rnnoise_create(0);\n    if (!this.rnnoiseState) {\n      throw new Error('Failed to create RNNoise state');\n    }\n    \n    // Allocate memory\n    this.inputPtr = this.wasmModule._malloc(480 * 4);\n    this.outputPtr = this.wasmModule._malloc(480 * 4);\n    \n    // Warm up the model\n    await this.warmupModel();\n    \n    this.logger.debug('WASM module loaded successfully');\n  }\n  \n  private async warmupModel(): Promise<void> {\n    this.logger.debug('Warming up noise reduction model...');\n    const silentFrame = new Float32Array(480);\n    \n    for (let i = 0; i < 10; i++) {\n      this.processFrame(silentFrame);\n    }\n  }\n  \n  private processFrame(frame: Float32Array): Float32Array {\n    if (!this.wasmModule || !this.rnnoiseState || !this.inputPtr || !this.outputPtr) {\n      throw new Error('WASM module not initialized');\n    }\n    \n    // Copy to WASM heap\n    this.wasmModule.HEAPF32.set(frame, this.inputPtr >> 2);\n    \n    // Process with RNNoise\n    this.wasmModule._rnnoise_process_frame(\n      this.rnnoiseState,\n      this.outputPtr,\n      this.inputPtr\n    );\n    \n    // Get output\n    const output = new Float32Array(480);\n    for (let i = 0; i < 480; i++) {\n      output[i] = this.wasmModule.HEAPF32[(this.outputPtr >> 2) + i];\n    }\n    \n    return output;\n  }\n  \n  async processStream(\n    stream: MediaStream,\n    chunkConfig?: ChunkConfig\n  ): Promise<StreamController> {\n    this.stateManager.requireState('ready', 'processing');\n    \n    const streamId = this.generateStreamId();\n    this.logger.info(`Processing stream ${streamId}`);\n    \n    try {\n      const controller = await this.createStreamController(stream, streamId, chunkConfig);\n      this.activeStreams.set(streamId, controller);\n      \n      if (this.activeStreams.size === 1) {\n        this.stateManager.transitionTo('processing');\n        this.emit('processing-start');\n      }\n      \n      return controller;\n      \n    } catch (error) {\n      const murmubaraError = new MurmubaraError(\n        ErrorCodes.PROCESSING_FAILED,\n        `Failed to process stream: ${error instanceof Error ? error.message : String(error)}`,\n        error\n      );\n      this.emit('error', murmubaraError);\n      throw murmubaraError;\n    }\n  }\n  \n  private async createStreamController(\n    stream: MediaStream,\n    streamId: string,\n    chunkConfig?: ChunkConfig\n  ): Promise<StreamController> {\n    if (!this.audioContext) {\n      throw new Error('Audio context not initialized');\n    }\n    \n    const source = this.audioContext.createMediaStreamSource(stream);\n    const destination = this.audioContext.createMediaStreamDestination();\n    const processor = this.audioContext.createScriptProcessor(this.config.bufferSize, 1, 1);\n    \n    // Create pre-filters for medical equipment noise\n    const notchFilter1 = this.audioContext.createBiquadFilter();\n    notchFilter1.type = 'notch';\n    notchFilter1.frequency.value = 1000; // Common medical equipment beep frequency\n    notchFilter1.Q.value = 30; // Narrow notch\n    \n    const notchFilter2 = this.audioContext.createBiquadFilter();\n    notchFilter2.type = 'notch';\n    notchFilter2.frequency.value = 2000; // Harmonics of beeps\n    notchFilter2.Q.value = 30;\n    \n    const highPassFilter = this.audioContext.createBiquadFilter();\n    highPassFilter.type = 'highpass';\n    highPassFilter.frequency.value = 80; // Remove low-frequency rumble from machines\n    highPassFilter.Q.value = 0.7;\n    \n    const lowShelfFilter = this.audioContext.createBiquadFilter();\n    lowShelfFilter.type = 'lowshelf';\n    lowShelfFilter.frequency.value = 200; // Reduce echo/room resonance\n    lowShelfFilter.gain.value = -3; // Gentle reduction\n    \n    let isPaused = false;\n    let isStopped = false;\n    const inputBuffer: number[] = [];\n    const outputBuffer: number[] = [];\n    \n    // Setup chunk processor if configured\n    let chunkProcessor: ChunkProcessor | undefined;\n    if (chunkConfig) {\n      chunkProcessor = new ChunkProcessor(\n        this.audioContext.sampleRate,\n        chunkConfig,\n        this.logger,\n        this.metricsManager\n      );\n      \n      // Forward chunk events\n      chunkProcessor.on('chunk-processed', (metrics) => {\n        this.logger.debug('Chunk processed:', metrics);\n        this.metricsManager.recordChunk(metrics);\n      });\n    }\n    \n    processor.onaudioprocess = (event) => {\n      if (isStopped || isPaused) {\n        event.outputBuffer.getChannelData(0).fill(0);\n        return;\n      }\n      \n      const input = event.inputBuffer.getChannelData(0);\n      const output = event.outputBuffer.getChannelData(0);\n      \n      // Update metrics\n      const inputLevel = this.metricsManager.calculateRMS(input);\n      const inputPeak = this.metricsManager.calculatePeak(input);\n      this.metricsManager.updateInputLevel(inputPeak);\n      \n      // Add to buffer\n      for (let i = 0; i < input.length; i++) {\n        inputBuffer.push(input[i]);\n      }\n      \n      // If using chunk processing, add samples to chunk processor\n      if (chunkProcessor && !isPaused && !isStopped) {\n        chunkProcessor.addSamples(input);\n      }\n      \n      // Process frames\n      let totalInputRMS = 0;\n      let totalOutputRMS = 0;\n      let framesProcessed = 0;\n      \n      while (inputBuffer.length >= 480) {\n        const frame = new Float32Array(inputBuffer.splice(0, 480));\n        const frameInputRMS = this.metricsManager.calculateRMS(frame);\n        \n        const processed = this.processFrame(frame);\n        const frameOutputRMS = this.metricsManager.calculateRMS(processed);\n        \n        // Apply noise reduction level adjustment\n        const reductionFactor = this.getReductionFactor();\n        for (let i = 0; i < processed.length; i++) {\n          processed[i] *= reductionFactor;\n          outputBuffer.push(processed[i]);\n        }\n        \n        // Accumulate RMS values for accurate noise reduction calculation\n        totalInputRMS += frameInputRMS;\n        totalOutputRMS += frameOutputRMS * reductionFactor; // Account for reduction factor\n        framesProcessed++;\n        \n        this.metricsManager.recordFrame();\n      }\n      \n      // Output processed audio\n      for (let i = 0; i < output.length; i++) {\n        if (outputBuffer.length > 0) {\n          output[i] = outputBuffer.shift()!;\n        } else {\n          output[i] = 0;\n        }\n      }\n      \n      // Update output metrics\n      const outputLevel = this.metricsManager.calculateRMS(output);\n      const outputPeak = this.metricsManager.calculatePeak(output);\n      this.metricsManager.updateOutputLevel(outputPeak);\n      \n      // Calculate noise reduction based on actual processed frames\n      if (framesProcessed > 0) {\n        const avgInputRMS = totalInputRMS / framesProcessed;\n        const avgOutputRMS = totalOutputRMS / framesProcessed;\n        const reduction = avgInputRMS > 0 ? Math.max(0, (1 - avgOutputRMS / avgInputRMS) * 100) : 0;\n        this.metricsManager.updateNoiseReduction(reduction);\n      }\n    };\n    \n    // Connect filters in chain: source -> filters -> processor -> destination\n    source.connect(highPassFilter);\n    highPassFilter.connect(notchFilter1);\n    notchFilter1.connect(notchFilter2);\n    notchFilter2.connect(lowShelfFilter);\n    lowShelfFilter.connect(processor);\n    processor.connect(destination);\n    \n    const controller: StreamController = {\n      stream: destination.stream,\n      processor: {\n        id: streamId,\n        state: 'processing',\n        inputNode: source,\n        outputNode: destination,\n      },\n      stop: () => {\n        isStopped = true;\n        \n        // Flush any remaining chunks\n        if (chunkProcessor) {\n          chunkProcessor.flush();\n        }\n        \n        processor.disconnect();\n        source.disconnect();\n        this.activeStreams.delete(streamId);\n        this.logger.info(`Stream ${streamId} stopped`);\n        \n        if (this.activeStreams.size === 0) {\n          this.stateManager.transitionTo('ready');\n          this.emit('processing-end');\n        }\n      },\n      pause: () => {\n        isPaused = true;\n        controller.processor.state = 'paused';\n        this.logger.debug(`Stream ${streamId} paused`);\n      },\n      resume: () => {\n        isPaused = false;\n        controller.processor.state = 'processing';\n        this.logger.debug(`Stream ${streamId} resumed`);\n      },\n      getState: () => controller.processor.state as EngineState,\n    };\n    \n    return controller;\n  }\n  \n  private getReductionFactor(): number {\n    switch (this.config.noiseReductionLevel) {\n      case 'low': return 0.9;\n      case 'medium': return 0.7;\n      case 'high': return 0.5;\n      case 'auto': return 0.7; // TODO: Implement auto adjustment\n      default: return 0.7;\n    }\n  }\n  \n  private generateStreamId(): string {\n    return `stream-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n  }\n  \n  async destroy(force: boolean = false): Promise<void> {\n    if (!this.stateManager.canTransitionTo('destroying')) {\n      if (force) {\n        this.logger.warn('Force destroying engine');\n      } else {\n        throw new MurmubaraError(\n          ErrorCodes.CLEANUP_FAILED,\n          'Cannot destroy engine in current state'\n        );\n      }\n    }\n    \n    this.stateManager.transitionTo('destroying');\n    this.logger.info('Destroying Murmuraba engine...');\n    \n    try {\n      // Stop all active streams\n      for (const [id, controller] of this.activeStreams) {\n        controller.stop();\n      }\n      this.activeStreams.clear();\n      \n      // Stop metrics\n      this.metricsManager.stopAutoUpdate();\n      \n      // Terminate workers\n      this.workerManager.terminateAll();\n      \n      // Clean up WASM\n      if (this.wasmModule) {\n        if (this.inputPtr) this.wasmModule._free(this.inputPtr);\n        if (this.outputPtr) this.wasmModule._free(this.outputPtr);\n        if (this.rnnoiseState) this.wasmModule._rnnoise_destroy(this.rnnoiseState);\n      }\n      \n      // Close audio context\n      if (this.audioContext && this.audioContext.state !== 'closed') {\n        await this.audioContext.close();\n      }\n      \n      // Clear timers\n      if (this.cleanupTimer) {\n        clearTimeout(this.cleanupTimer);\n      }\n      \n      // Remove all event listeners\n      this.removeAllListeners();\n      \n      this.stateManager.transitionTo('destroyed');\n      this.emit('destroyed');\n      this.logger.info('Murmuraba engine destroyed successfully');\n      \n    } catch (error) {\n      this.stateManager.transitionTo('error');\n      const murmubaraError = new MurmubaraError(\n        ErrorCodes.CLEANUP_FAILED,\n        `Cleanup failed: ${error instanceof Error ? error.message : String(error)}`,\n        error\n      );\n      this.emit('error', murmubaraError);\n      throw murmubaraError;\n    }\n  }\n  \n  getMetrics(): ProcessingMetrics {\n    return this.metricsManager.getMetrics();\n  }\n  \n  onMetricsUpdate(callback: (metrics: ProcessingMetrics) => void): void {\n    this.on('metrics-update', callback);\n  }\n  \n  getDiagnostics(): DiagnosticInfo {\n    return {\n      engineVersion: '2.0.0',\n      wasmLoaded: !!this.wasmModule,\n      activeProcessors: this.activeStreams.size,\n      memoryUsage: (performance as any).memory?.usedJSHeapSize || 0,\n      processingTime: this.metricsManager.getMetrics().processingLatency,\n      engineState: this.stateManager.getState(),\n      errors: this.errorHistory,\n    };\n  }\n  \n  private recordError(error: string): void {\n    this.errorHistory.push({\n      timestamp: Date.now(),\n      error,\n    });\n    \n    // Keep only last 100 errors\n    if (this.errorHistory.length > 100) {\n      this.errorHistory.shift();\n    }\n  }\n}","import { MurmubaraEngine } from './core/MurmubaraEngine';\nimport { MurmubaraConfig } from './types';\n\nlet globalEngine: MurmubaraEngine | null = null;\n\nexport async function initializeAudioEngine(config?: MurmubaraConfig): Promise<void> {\n  if (globalEngine) {\n    throw new Error('Audio engine is already initialized. Call destroyEngine() first.');\n  }\n  \n  globalEngine = new MurmubaraEngine(config);\n  await globalEngine.initialize();\n}\n\nexport function getEngine(): MurmubaraEngine {\n  if (!globalEngine) {\n    throw new Error('Audio engine not initialized. Call initializeAudioEngine() first.');\n  }\n  return globalEngine;\n}\n\nexport async function processStream(stream: MediaStream) {\n  const engine = getEngine();\n  return engine.processStream(stream);\n}\n\nexport async function processStreamChunked(\n  stream: MediaStream,\n  config: {\n    chunkDuration: number;\n    onChunkProcessed?: (chunk: any) => void;\n  }\n) {\n  const engine = getEngine();\n  return engine.processStream(stream, config);\n}\n\nexport async function destroyEngine(options?: { force?: boolean }): Promise<void> {\n  if (!globalEngine) {\n    return;\n  }\n  \n  await globalEngine.destroy(options?.force || false);\n  globalEngine = null;\n}\n\nexport function getEngineStatus() {\n  if (!globalEngine) {\n    return 'uninitialized';\n  }\n  return globalEngine.getDiagnostics().engineState;\n}\n\nexport function getDiagnostics() {\n  const engine = getEngine();\n  return engine.getDiagnostics();\n}\n\nexport function onMetricsUpdate(callback: (metrics: any) => void) {\n  const engine = getEngine();\n  engine.onMetricsUpdate(callback);\n}","/**\n * Murmuraba v1.2.1\n * Real-time audio noise reduction with advanced chunked processing\n */\n\n// Core exports\nexport { MurmubaraEngine } from './core/MurmubaraEngine';\nexport { EventEmitter } from './core/EventEmitter';\nexport { StateManager } from './core/StateManager';\nexport { Logger } from './core/Logger';\n\n// Manager exports\nexport { WorkerManager } from './managers/WorkerManager';\nexport { MetricsManager } from './managers/MetricsManager';\n\n// Type exports\nexport * from './types';\n\n// Re-export API functions\nexport {\n  initializeAudioEngine,\n  getEngine,\n  processStream,\n  processStreamChunked,\n  destroyEngine,\n  getEngineStatus,\n  getDiagnostics,\n  onMetricsUpdate\n} from './api';\n\n// Export version\nexport const VERSION = '1.2.1';\nexport const MURMURABA_VERSION = VERSION;\n\n// Re-export error codes\nexport { ErrorCodes } from './types';\n\n// Hook export at the end to avoid circular dependency\nexport { useMurmubaraEngine } from './hooks/useMurmubaraEngine';","import { useEffect, useRef, useState, useCallback } from 'react';\nimport {\n  initializeAudioEngine,\n  destroyEngine,\n  processStream,\n  processStreamChunked,\n  getEngineStatus,\n  getDiagnostics,\n  onMetricsUpdate,\n} from '../api';\nimport {\n  MurmubaraConfig,\n  EngineState,\n  ProcessingMetrics,\n  StreamController,\n  DiagnosticInfo,\n  ChunkMetrics,\n} from '../types';\n\ninterface UseMurmubaraEngineOptions extends MurmubaraConfig {\n  autoInitialize?: boolean;\n}\n\ninterface UseMurmubaraEngineReturn {\n  // State\n  isInitialized: boolean;\n  isLoading: boolean;\n  error: string | null;\n  engineState: EngineState;\n  metrics: ProcessingMetrics | null;\n  diagnostics: DiagnosticInfo | null;\n  \n  // Actions\n  initialize: () => Promise<void>;\n  destroy: (force?: boolean) => Promise<void>;\n  processStream: (stream: MediaStream) => Promise<StreamController>;\n  processStreamChunked: (\n    stream: MediaStream,\n    config: {\n      chunkDuration: number;\n      onChunkProcessed?: (chunk: ChunkMetrics) => void;\n    }\n  ) => Promise<StreamController>;\n  \n  // Utility\n  getDiagnostics: () => DiagnosticInfo | null;\n  resetError: () => void;\n}\n\nexport function useMurmubaraEngine(\n  options: UseMurmubaraEngineOptions = {}\n): UseMurmubaraEngineReturn {\n  const { autoInitialize = false, ...config } = options;\n  \n  const [isInitialized, setIsInitialized] = useState(false);\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  const [engineState, setEngineState] = useState<EngineState>('uninitialized');\n  const [metrics, setMetrics] = useState<ProcessingMetrics | null>(null);\n  const [diagnostics, setDiagnostics] = useState<DiagnosticInfo | null>(null);\n  \n  const metricsUnsubscribeRef = useRef<(() => void) | null>(null);\n  const initializePromiseRef = useRef<Promise<void> | null>(null);\n  \n  const initialize = useCallback(async () => {\n    if (initializePromiseRef.current) {\n      return initializePromiseRef.current;\n    }\n    \n    if (isInitialized) {\n      return;\n    }\n    \n    setIsLoading(true);\n    setError(null);\n    \n    initializePromiseRef.current = (async () => {\n      try {\n        await initializeAudioEngine(config);\n        \n        // Set up metrics listener\n        onMetricsUpdate((newMetrics: ProcessingMetrics) => {\n          setMetrics(newMetrics);\n        });\n        \n        setIsInitialized(true);\n        setEngineState('ready');\n        updateDiagnostics();\n        \n      } catch (err) {\n        const errorMessage = err instanceof Error ? err.message : String(err);\n        setError(errorMessage);\n        setEngineState('error');\n        throw err;\n      } finally {\n        setIsLoading(false);\n        initializePromiseRef.current = null;\n      }\n    })();\n    \n    return initializePromiseRef.current;\n  }, [config, isInitialized]);\n  \n  const destroy = useCallback(async (force: boolean = false) => {\n    if (!isInitialized) {\n      return;\n    }\n    \n    try {\n      await destroyEngine({ force });\n      setIsInitialized(false);\n      setEngineState('destroyed');\n      setMetrics(null);\n      setDiagnostics(null);\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : String(err);\n      setError(errorMessage);\n      throw err;\n    }\n  }, [isInitialized]);\n  \n  const processStreamWrapper = useCallback(async (stream: MediaStream) => {\n    if (!isInitialized) {\n      throw new Error('Engine not initialized');\n    }\n    \n    try {\n      const controller = await processStream(stream);\n      updateDiagnostics();\n      return controller;\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : String(err);\n      setError(errorMessage);\n      throw err;\n    }\n  }, [isInitialized]);\n  \n  const processStreamChunkedWrapper = useCallback(async (\n    stream: MediaStream,\n    chunkConfig: {\n      chunkDuration: number;\n      onChunkProcessed?: (chunk: ChunkMetrics) => void;\n    }\n  ) => {\n    if (!isInitialized) {\n      throw new Error('Engine not initialized');\n    }\n    \n    try {\n      const controller = await processStreamChunked(stream, chunkConfig);\n      updateDiagnostics();\n      return controller;\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : String(err);\n      setError(errorMessage);\n      throw err;\n    }\n  }, [isInitialized]);\n  \n  const updateDiagnostics = useCallback(() => {\n    if (!isInitialized) {\n      setDiagnostics(null);\n      return null;\n    }\n    \n    try {\n      const diag = getDiagnostics();\n      setDiagnostics(diag);\n      setEngineState(diag.engineState);\n      return diag;\n    } catch {\n      return null;\n    }\n  }, [isInitialized]);\n  \n  const resetError = useCallback(() => {\n    setError(null);\n  }, []);\n  \n  // Auto-initialize if requested\n  useEffect(() => {\n    if (autoInitialize && !isInitialized && !isLoading) {\n      initialize();\n    }\n  }, [autoInitialize, isInitialized, isLoading, initialize]);\n  \n  // Update engine state periodically\n  useEffect(() => {\n    if (!isInitialized) return;\n    \n    const interval = setInterval(() => {\n      try {\n        const status = getEngineStatus();\n        setEngineState(status as EngineState);\n      } catch {\n        // Engine might be destroyed\n      }\n    }, 1000);\n    \n    return () => clearInterval(interval);\n  }, [isInitialized]);\n  \n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      if (isInitialized) {\n        destroy(true).catch(console.error);\n      }\n    };\n  }, []);\n  \n  return {\n    // State\n    isInitialized,\n    isLoading,\n    error,\n    engineState,\n    metrics,\n    diagnostics,\n    \n    // Actions\n    initialize,\n    destroy,\n    processStream: processStreamWrapper,\n    processStreamChunked: processStreamChunkedWrapper,\n    \n    // Utility\n    getDiagnostics: updateDiagnostics,\n    resetError,\n  };\n}"],"names":["EventEmitter","constructor","this","events","Map","on","event","handler","has","set","Set","get","add","off","handlers","delete","size","emit","args","forEach","error","console","String","once","wrappedHandler","removeAllListeners","clear","listenerCount","StateManager","currentState","allowedTransitions","getState","canTransitionTo","newState","includes","transitionTo","warn","oldState","isInState","states","requireState","Error","join","reset","Logger","prefix","level","setLevel","setLogHandler","onLog","shouldLog","levels","currentIndex","indexOf","messageIndex","log","message","data","timestamp","Date","toISOString","formattedMessage","toUpperCase","logMethod","undefined","info","debug","MurmubaraError","code","details","super","name","ErrorCodes","WASM_NOT_LOADED","INVALID_STREAM","ENGINE_BUSY","INITIALIZATION_FAILED","PROCESSING_FAILED","CLEANUP_FAILED","WORKER_ERROR","INVALID_CONFIG","NOT_INITIALIZED","ALREADY_INITIALIZED","WorkerManager","logger","workers","createWorker","id","workerPath","worker","Worker","getWorker","sendMessage","postMessage","terminateWorker","terminate","terminateAll","getActiveWorkerCount","getWorkerIds","Array","from","keys","MetricsManager","metrics","noiseReductionLevel","processingLatency","inputLevel","outputLevel","now","frameCount","droppedFrames","frameTimestamps","maxFrameHistory","startAutoUpdate","intervalMs","stopAutoUpdate","updateInterval","setInterval","calculateLatency","clearInterval","updateInputLevel","Math","max","min","updateOutputLevel","updateNoiseReduction","recordFrame","push","length","shift","recordDroppedFrame","recordChunk","chunk","deltas","i","avgDelta","reduce","a","b","getMetrics","calculateRMS","samples","sum","sqrt","calculatePeak","peak","abs","ChunkProcessor","sampleRate","config","metricsManager","currentChunk","chunkStartTime","chunkIndex","currentSampleCount","overlapBuffer","chunkDuration","onChunkProcessed","overlap","samplesPerChunk","floor","addSamples","Float32Array","processCurrentChunk","chunkId","endTime","totalSamples","extractChunkSamples","processedSamples","applyOverlap","startTime","channelCount","emitChunkMetrics","result","offset","remainingSamples","buffer","samplesToTake","subarray","overlapSamples","previousOverlap","combineBuffers","fadeLength","fadeIn","fadeOut","originalSamples","originalRMS","processedRMS","originalPeak","processedPeak","noiseRemoved","originalSize","processedSize","duration","toFixed","latency","flush","buffers","totalLength","buf","getStatus","bufferFillPercentage","MurmubaraEngine","activeStreams","errorHistory","logLevel","bufferSize","algorithm","autoCleanup","cleanupDelay","useWorker","stateManager","workerManager","setupEventForwarding","setupAutoCleanup","cleanupTimer","clearTimeout","setTimeout","destroy","initialize","initPromise","performInitialization","audioContext","AudioContext","loadWasmModule","murmubaraError","script","document","createElement","src","Promise","resolve","reject","onload","onerror","head","appendChild","createRNNWasmModule","window","wasmModule","locateFile","filename","endsWith","rnnoiseState","_rnnoise_create","inputPtr","_malloc","outputPtr","warmupModel","silentFrame","processFrame","frame","HEAPF32","_rnnoise_process_frame","output","processStream","stream","chunkConfig","streamId","generateStreamId","controller","createStreamController","source","createMediaStreamSource","destination","createMediaStreamDestination","processor","createScriptProcessor","notchFilter1","createBiquadFilter","type","frequency","value","Q","notchFilter2","highPassFilter","lowShelfFilter","gain","isPaused","isStopped","inputBuffer","outputBuffer","chunkProcessor","onaudioprocess","getChannelData","fill","input","inputPeak","totalInputRMS","totalOutputRMS","framesProcessed","splice","frameInputRMS","processed","frameOutputRMS","reductionFactor","getReductionFactor","outputPeak","avgInputRMS","avgOutputRMS","reduction","connect","state","inputNode","outputNode","stop","disconnect","pause","resume","random","toString","substr","force","_free","_rnnoise_destroy","close","onMetricsUpdate","callback","getDiagnostics","engineVersion","wasmLoaded","activeProcessors","memoryUsage","performance","memory","usedJSHeapSize","processingTime","engineState","errors","recordError","globalEngine","async","initializeAudioEngine","getEngine","processStreamChunked","destroyEngine","options","getEngineStatus","VERSION","MURMURABA_VERSION","autoInitialize","isInitialized","setIsInitialized","useState","isLoading","setIsLoading","setError","setEngineState","setMetrics","diagnostics","setDiagnostics","useRef","initializePromiseRef","useCallback","current","newMetrics","updateDiagnostics","err","errorMessage","processStreamWrapper","processStreamChunkedWrapper","diag","resetError","useEffect","interval","status","catch"],"mappings":"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"}